{"version":3,"file":"script.bundle.js","mappings":";;;;;;;;;;;;;;AAAA;AACA;AACe;AACf,qEAAqE;AACrE,8CAA8C;AAC9C,oCAAoC;AACpC,qCAAqC;AACrC,GAAG;AACH,kBAAkB;AAClB,yCAAyC;AACzC;AACA,sCAAsC;AACtC,yCAAyC;AACzC,GAAG;AACH,iBAAiB;AACjB,wCAAwC;AACxC;AACA,qDAAqD;AACrD,wDAAwD;AACxD,6BAA6B;AAC7B,uCAAuC;AACvC,kEAAkE;AAClE;AACA;AACA,4EAA4E;AAC5E;AACA;AACA,GAAG;AACH,GAAG;AACH;AACA;AACA,wBAAwB;AACxB,sDAAsD,qFAAqF;AAC3I,gCAAgC,+FAA+F,GAAG;AAClI,WAAW;AACX;AACA;AACA,qGAAqG;AACrG,IAAI;AACJ,sGAAsG;AACtG;AACA;AACA;AACA,wDAAwD;AACxD,wDAAwD;AACxD;AACA,2CAA2C;AAC3C,+CAA+C;AAC/C,mDAAmD;AACnD,0EAA0E;AAC1E,MAAM;AACN,wCAAwC;AACxC,+DAA+D;AAC/D;AACA;AACA,+BAA+B;AAC/B;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ,GAAG;AACH,kEAAkE;AAClE,oDAAoD,gBAAgB,OAAO;AAC3E,+EAA+E;AAC/E,iDAAiD;AACjD,qDAAqD;AACrD,QAAQ;AACR,0CAA0C;AAC1C;AACA;AACA,iCAAiC;AACjC;AACA,OAAO;AACP;AACA;AACA,MAAM,GAAG;AACT;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA,0CAA0C;AAC1C,mCAAmC;AACnC,0CAA0C;AAC1C,KAAK;AACL,iCAAiC;AACjC;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC1GA;AACqD;AACrD;AACA;AACe;AACf;AACA,kFAAkF;AAClF;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA,iEAAiE;AACjE,uBAAuB;AACvB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,qCAAqC;AACrC;AACA;AACA,KAAK,OAAO;AACZ,yEAAyE;AACzE;AACA;AACA,eAAe,aAAa,MAAM,aAAa;AAC/C,sCAAsC,WAAW;AACjD,oCAAoC,WAAW;AAC/C;AACA;AACA;AACA,2CAA2C,WAAW;AACtD;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iCAAiC;AACrD;AACA;AACA;AACA,kBAAkB,KAAK,MAAM,OAAO;AACpC,yCAAyC,MAAM;AAC/C,uCAAuC,MAAM;AAC7C;AACA;AACA;AACA,8CAA8C,MAAM;AACpD;AACA;AACA;AACA,MAAM;AACN;AACA,CAAC,mEAAY;AACb;AACA,kBAAkB,iCAAiC,OAAO,uFAAuF,iCAAiC;AAClL,kFAAkF;AAClF,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;;;;;;;;;;;;;ACpGA;AACe,mBAAmB,qFAAqF,IAAI;AAC3H;AACA,+DAA+D;AAC/D,gEAAgE;AAChE,gEAAgE;AAChE,0DAA0D;AAC1D,6DAA6D;AAC7D,wBAAwB;AACxB,4BAA4B;AAC5B,8BAA8B;AAC9B,mCAAmC,cAAc,GAAG;AACpD,MAAM,OAAO;AACb,8CAA8C;AAC9C;AACA,8BAA8B;AAC9B,6BAA6B;AAC7B,sBAAsB;AACtB;AACA,iBAAiB;AACjB,kCAAkC;AAClC;AACA,0DAA0D;AAC1D,sDAAsD;AACtD,+BAA+B;AAC/B,qCAAqC,WAAW,GAAG;AACnD,OAAO,OAAO;AACd,6CAA6C;AAC7C;AACA;AACA,4BAA4B;AAC5B,kCAAkC;AAClC;AACA,2CAA2C;AAC3C;AACA,KAAK;AACL,2CAA2C;AAC3C;AACA,KAAK;AACL;AACA;AACA,kDAAkD;AAClD,mDAAmD;AACnD,iDAAiD;AACjD,iDAAiD;AACjD,2DAA2D;AAC3D,8DAA8D;AAC9D,wDAAwD;AACxD,oDAAoD;AACpD,mEAAmE;AACnE,qBAAqB;AACrB,sBAAsB;AACtB,2BAA2B;AAC3B,gCAAgC,cAAc,GAAG;AACjD,iCAAiC,WAAW;AAC5C,GAAG,OAAO;AACV,2CAA2C;AAC3C;AACA;AACA,sDAAsD;AACtD,qCAAqC;AACrC,4CAA4C;AAC5C,0CAA0C;AAC1C,2BAA2B;AAC3B,mCAAmC;AACnC,EAAE;AACF,qCAAqC;AACrC,4CAA4C;AAC5C,qBAAqB;AACrB,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,iBAAiB,mBAAmB,OAAO;AAC3C,4CAA4C;AAC5C,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,0BAA0B;AAC1B;AACA,oBAAoB;AACpB,qBAAqB;AACrB;AACA,iCAAiC;AACjC,kCAAkC;AAClC;AACA,mCAAmC;AACnC;AACA,kCAAkC,WAAW;AAC7C,IAAI;AACJ;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,wCAAwC;AACxC,0BAA0B;AAC1B,qEAAqE;AACrE;AACA,IAAI;AACJ,gDAAgD;AAChD;AACA;AACA,+CAA+C,YAAY,MAAM;AACjE,yBAAyB;AACzB,+BAA+B;AAC/B,IAAI;AACJ,iBAAiB;AACjB;AACA;AACA;AACA,EAAE;AACF,wCAAwC;AACxC,2EAA2E;AAC3E;AACA,oBAAoB;AACpB,IAAI;AACJ;AACA,gDAAgD;AAChD;AACA,+CAA+C,YAAY,MAAM;AACjE,qCAAqC;AACrC,mBAAmB;AACnB,IAAI;AACJ,iBAAiB;AACjB;AACA;AACA;AACA,EAAE;AACF;AACA,yCAAyC;AACzC,2DAA2D;AAC3D,yBAAyB;AACzB;AACA,gDAAgD,YAAY;AAC5D;AACA;AACA,GAAG;AACH,EAAE;AACF;;;;;;;;;;;;;;;;ACrKA;AAC6D;AACZ;AACjD;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,EAAE;AACF,+BAA+B;AAC/B;AACA,uBAAuB;AACvB,2DAA2D;AAC3D,wDAAwD;AACxD,6CAA6C;AAC7C,wCAAwC;AACxC,gDAAgD;AAChD;AACA;AACA;AACA,MAAM;AACN,kCAAkC;AAClC,0DAA0D;AAC1D,wCAAwC;AACxC,6BAA6B;AAC7B,8CAA8C;AAC9C;AACA,OAAO;AACP;AACA;AACA,wEAAwE;AACxE,GAAG,+DAAQ;AACX;AACA,oBAAoB;AACpB,wBAAwB;AACxB,uCAAuC;AACvC,6BAA6B;AAC7B,KAAK,gBAAgB;AACrB,sCAAsC;AACtC,KAAK,kBAAkB;AACvB,mBAAmB;AACnB,KAAK;AACL,GAAG;AACH;AACA,qCAAqC;AACrC,oEAAoE;AACpE,yCAAyC;AACzC,EAAE,0DAAe,0BAA0B;AAC3C,qDAAqD;AACrD,8CAA8C;AAC9C;AACA;AACA,gDAAgD;AAChD,gCAAgC,QAAQ;AACxC;AACA,KAAK;AACL,wDAAwD;AACxD,qBAAqB;AACrB,yBAAyB;AACzB,0CAA0C;AAC1C;AACA,GAAG,2DAAgB,YAAY;AAC/B,GAAG;AACH;AACA;;;;;;;;;;;;;;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA,qBAAqB;AACrB,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA,kEAAkE;AAClE;AACA,qFAAqF;AACrF,EAAE;AACF,+DAA+D;AAC/D;AACA,+EAA+E;AAC/E,oCAAoC;AACpC;AACA,EAAE;AACF;AACA,uEAAuE;AACvE;AACA;AACA,EAAE;AACF;AACA,yGAAyG;AACzG,iDAAiD;AACjD,kEAAkE;AAClE,IAAI;AACJ,GAAG,IAAI,GAAG,WAAW,GAAG;AACxB,6DAA6D;AAC7D;AACA,+DAAe,KAAK,EAAC;AACI;;;;;;;;;;;;;;;AC/CzB;AACA;AACe;AACf;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,oEAAoE;AACpE,+BAA+B;AAC/B,0BAA0B;AAC1B;AACA,wBAAwB;AACxB;AACA,IAAI;AACJ;AACA,EAAE;AACF;;;;;;;;;;;;;;ACnCA;AACA;AACe;AACf,mCAAmC;AACnC,sCAAsC;AACtC,0DAA0D;AAC1D,sDAAsD;AACtD,yDAAyD;AACzD;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,cAAc,IAAI;AAClB,IAAI;AACJ;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA,uDAAuD;AACvD,iBAAiB;AACjB,4BAA4B;AAC5B,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC7CA;AACA,wCAAwC;AACxC,mCAAmC;AACnC;AACA;AACA;AACA,GAAG;AACH;AACA,EAAE,GAAG;AACL,6BAA6B;AAC7B;AACA,sCAAsC;AACtC,kCAAkC;AAClC;AACA,mBAAmB;AACnB,qCAAqC,IAAI,YAAY,cAAc,IAAI;AACvE;AACA,6BAA6B;AAC7B;AACkB;;;;;;;UCnBlB;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA,8CAA8C;;;;;WCA9C;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;;;;ACNA;AACqC;AACE;AACA;AACA;AACA;AACM;AACI;AACE;AACnD;AACA;AACA,uCAAuC,kEAAe,kCAAkC;AACxF;AACA;AACA,CAAC,4DAAI;AACL;AACA;AACA,CAAC,6DAAK;AACN;AACA;AACA,CAAC,6DAAK;AACN;AACA;AACA,CAAC,6DAAK;AACN;AACA;AACA,CAAC,6DAAK;AACN;AACA;AACA,CAAC,gEAAQ,GAAG;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,CAAC,kEAAU;AACX;AACA,CAAC,E","sources":["webpack://food/./src/js/modules/calculator.js","webpack://food/./src/js/modules/cards.js","webpack://food/./src/js/modules/carousel.js","webpack://food/./src/js/modules/forms.js","webpack://food/./src/js/modules/modal.js","webpack://food/./src/js/modules/tabs.js","webpack://food/./src/js/modules/timer.js","webpack://food/./src/js/services/services.js","webpack://food/webpack/bootstrap","webpack://food/webpack/runtime/define property getters","webpack://food/webpack/runtime/hasOwnProperty shorthand","webpack://food/webpack/runtime/make namespace object","webpack://food/./src/js/script.js"],"sourcesContent":["/* eslint-disable linebreak-style */\r\n// CALCULATOR-----------------------------------------------------\r\nexport default function calculator() {\r\n\tconst result = document.querySelector('.calculating__result span'); // получили по селектору класс, в который будем записывать результат расчета\r\n\tlet sex, height, weight, age, ratio = 1.375; // объявили несколко переменных (через let так как они будут меняться): пол, рост, вес, возраст и коэффициент активности\r\n\tif (localStorage.getItem('sex')) { // назначим проверку при получении значений элементов из localStorage\r\n\t\tsex = localStorage.getItem('sex'); // присваиваем значение переменной sex из localStorage\r\n\t} else {\r\n\t\tsex = 'female'; // если нет значения элементов sex из localStorage, то вводим их вручную\r\n\t\tlocalStorage.setItem('sex', 'female'); // присваиваем в localStorage опционально значение полу\r\n\t}\r\n\tif (localStorage.getItem('ratio')) { // назначим проверку при получении значений элементов из localStorage\r\n\t\tratio = localStorage.getItem('ratio'); // присваиваем значение переменной ratio из localStorage\r\n\t} else {\r\n\t\tratio = 1.375; // если нет значения элементов ratio из localStorage, то вводим их вручную\r\n\t\tlocalStorage.setItem('ratio', 1.375); // присваиваем в localStorage опционально значение активности\r\n\t}\r\n\tfunction initLocalSettings(selector, activeClass) { // перебираем все элементы в sex и ratio, при совпадении с ключами в localStorage с sex: female и ratio: 1.375, назначаем класс активности\r\n\t\tconst elements = document.querySelectorAll(selector); // присваиваем селектор переменной elements\r\n\t\telements.forEach(elem => { // начинаемперебирать все элементы в sex и ratio\r\n\t\t\telem.classList.remove(activeClass); // удаляем сразу все классы активности заранее\r\n\t\t\tif (elem.getAttribute('id') === localStorage.getItem('sex')) { // перебираем по id соответствия в localStorage с sex: female с назначением класса активности\r\n\t\t\t\telem.classList.add(activeClass);\r\n\t\t\t}\r\n\t\t\tif (elem.getAttribute('data-ratio') === localStorage.getItem('ratio')) { // перебираем по id соответствия в localStorage с ratio: 1.375 с назначением класса активности\r\n\t\t\t\telem.classList.add(activeClass);\r\n\t\t\t}\r\n\t\t});\r\n\t} // при этом данная функция должна вызываться один раз при занесенных пользователем данных!!!!\r\n\tinitLocalSettings('#gender div', 'calculating__choose-item_active');\r\n\tinitLocalSettings('.calculating__choose_big div', 'calculating__choose-item_active');\r\n\tfunction calcTotal() { // подсчитываем конечный результат, но начинать подсчет будем с проверки наличия всех заполненных данных, запускаться будет при внесении изменений\r\n\t\tif (!sex || !height || !weight || !age || !ratio) { // строка (+'fbgdfj') при преобразовании в числовой формат дает NaN, а NaN == false; при проверке значения: true, т.е. на наличие =>\r\n\t\t\tresult.textContent = '?...'; // => всех заполненых переменных, они преобразуются в конструкции switch к числу (+input.value;); но если хотя бы одно значение будет NaN == false, то =>\r\n\t\t\treturn; // => прерываем досрочно функцию с сообщением '?...' и все условия после return работать не будут!!!\r\n\t\t}\r\n\t\tif (sex === 'female') {\r\n\t\t\tresult.textContent = Math.round((447.6 + (9.2 * weight) + (3.1 * height) - (4.3 * age)) * ratio); // метод Math.round() - округляет до целого числа \r\n\t\t} else {\r\n\t\t\tresult.textContent = Math.round((88.36 + (13.4 * weight) + (4.8 * height) - (5.7 * age)) * ratio); // метод Math.round() - округляет до целого числа \r\n\t\t}\r\n\t}\r\n\tcalcTotal();\r\n\tfunction getStaticInformation(selector, activeClass) { // применять функцию будем на двух аргументах: на селекторе и классе активности, для получения информации со статических блоков\r\n\t\tconst elements = document.querySelectorAll(selector); // получим элементы (все div) внутри блоков #gender и .calculating__choose_big\r\n\t\telements.forEach(elem => {\r\n\t\t\telem.addEventListener('click', (e) => { // отслеживаем все клики по родительскому элементу, который содержит все div (делегирование событий) при помощи коллбэк функции\r\n\t\t\t\tif (e.target.getAttribute('data-ratio')) { // если это блок - ratio (т.е. содержит атрибут data-ratio), то получаем значения по data-ratio атрибуту, \r\n\t\t\t\t\tratio = +e.target.getAttribute('data-ratio'); // присваиваем переменной ratio числовое значение атрибута data-ratio\r\n\t\t\t\t\tlocalStorage.setItem('ratio', +e.target.getAttribute('data-ratio')); // добавляем в localStorage постоянные данные, выбранные пользователем\r\n\t\t\t\t} else {\r\n\t\t\t\t\tsex = e.target.getAttribute('id'); // если блок - gender/sex, то значаения получаем по id\r\n\t\t\t\t\tlocalStorage.setItem('sex', e.target.getAttribute('id')); // добавляем в localStorage постоянные данные, выбранные пользователем\r\n\t\t\t\t}\r\n\t\t\t\tconsole.log(ratio, sex);\r\n\t\t\t\telements.forEach(elem => { // меняем классы активности\r\n\t\t\t\t\telem.classList.remove(activeClass);\r\n\t\t\t\t});\r\n\t\t\t\te.target.classList.add(activeClass);\r\n\t\t\t\tcalcTotal();\r\n\t\t\t});\r\n\t\t});\r\n\t\t// function getStaticInformation(parentSelector, activeClass) { // применять функцию будем на двух аргументах: на родительском селекторе и классе активности, для получения информации со статических блоков\r\n\t\t// \tconst elements = document.querySelectorAll(`${parentSelector} div`); // получим элементы (все div) внутри родительского блока\r\n\t\t// document.querySelector(parentSelector).addEventListener('click', (e) => { // отслеживаем все клики по родительскому элементу, который содержит все div (делегирование событий) при помощи коллбэк функции\r\n\t\t// \tif (e.target.getAttribute('data-ratio')) { // если это блок - ratio (т.е. содержит атрибут data-ratio), то получаем значения по data-ratio атрибуту, \r\n\t\t// \t\tratio = +e.target.getAttribute('data-ratio'); // присваиваем переменной ratio числовое значение атрибута data-ratio\r\n\t\t// \t} else {\r\n\t\t// \t\tsex = e.target.getAttribute('id'); // если блок - gender/sex, то значаения получаем по id \r\n\t\t// \t}\r\n\t\t// \tconsole.log(ratio, sex);\r\n\t\t// \telements.forEach(elem => { // меняем классы активности\r\n\t\t// \t\telem.classList.remove(activeClass);\r\n\t\t// \t});\r\n\t\t// \te.target.classList.add(activeClass);\r\n\t\t// \tcalcTotal();\r\n\t\t// }); // !!!но делегирование в данном случае создает сложность, когда кликаешь на родительский блок, он подсвечивается, так как ему назначается класс активности!!!\r\n\t\t// }\r\n\t}\r\n\tgetStaticInformation('#gender div', 'calculating__choose-item_active');\r\n\tgetStaticInformation('.calculating__choose_big div', 'calculating__choose-item_active');\r\n\tfunction getDynamicInformation(selector) { // функция обрабатывает каждый отдельный input\r\n\t\tconst input = document.querySelector(selector);\r\n\t\tinput.addEventListener('input', () => { // используем switch case конструкцию\r\n\t\t\tif (input.value.match(/\\D/g)) { // если мы вводим в input значение value не соответствующее цифрам, то не позволяем выполнять вычисления!!!\r\n\t\t\t\tinput.style.border = '2px solid red'; // так же задаём красныую обводку блоку input\r\n\t\t\t} else {\r\n\t\t\t\tinput.style.border = 'none'; // ПРОВЕРКА НА ОТМЕТКУ/ВВОД ДАННЫХ В ИНПУТ!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\r\n\t\t\t}\r\n\t\t\tswitch(input.getAttribute('id')) { // проверяем input по уникальному идентификатору\r\n\t\t\tcase 'height': // если это рост, то записываем в него значение роста\r\n\t\t\t\theight = +input.value;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'weight': // если это вес, то записываем в него значение веса\r\n\t\t\t\tweight = +input.value;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'age': // если это возраст, то записываем в него значение возраста\r\n\t\t\t\tage = +input.value;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcalcTotal();\r\n\t\t});\r\n\t}\r\n\tgetDynamicInformation('#height');\r\n\tgetDynamicInformation('#weight');\r\n\tgetDynamicInformation('#age');\r\n}","/* eslint-disable linebreak-style */\r\nimport {getResources} from '../services/services.js';\r\n\r\n// CLASSES-for-CARDS--------------------------------------------------\r\nexport default function cards() {    \r\n\tclass MenuCards {\r\n\t\tconstructor(srcImg, altText, title, descr, price, parentSelector, ...classes) { // добавил REST оператор, так как не известно - будут ли еще изменения в карточках меню\r\n\t\t\tthis.srcImg = srcImg;\r\n\t\t\tthis.altText = altText;\r\n\t\t\tthis.title = title;\r\n\t\t\tthis.descr = descr;\r\n\t\t\tthis.price = price;\r\n\t\t\tthis.transfer = 100; // курс доллара к рублю\r\n\t\t\tthis.classes = classes;\r\n\t\t\tthis.parentSelector = document.querySelector(parentSelector); // тут теперь лежит DOM  элемент!!!\t\t\t\r\n\t\t\tthis.changeToRub(); // вызываем метод после построения всех свойств объекта\r\n\t\t}\r\n\t\tchangeToRub() {\r\n\t\t\tthis.price = +this.price * this.transfer;\r\n\t\t}\r\n\t\trender() { // классическое название для формирование верстки\r\n\t\t\tconst element = document.createElement('div');\r\n\t\t\tif (this.classes.length === 0 ) { // если у массива this.classes нет классов, то присваиваем класс menu__item всем div элементам\r\n\t\t\t\tthis.element = 'menu__item';\r\n\t\t\t\telement.classList.add(this.element);\r\n\t\t\t} else { // если у массива this.classes хоть один класс присутствует, то добавляем класс\r\n\t\t\t\tthis.classes.forEach(className => element.classList.add(className)); // для каждого элемента массива обращаемся к classList созданного в element div и добавляю каждый класс, который находится в массиве className\t\t\t\t\r\n\t\t\t}\r\n\t\t\telement.innerHTML =`\t\t\t\t\t\r\n\t\t\t\t<img src=${this.srcImg} alt=${this.altText}>\r\n\t\t\t\t<h3 class=\"menu__item-subtitle\">${this.title}</h3>\r\n\t\t\t\t<div class=\"menu__item-descr\">${this.descr}</div>\r\n\t\t\t\t<div class=\"menu__item-divider\"></div>\r\n\t\t\t\t<div class=\"menu__item-price\">\r\n\t\t\t\t\t<div class=\"menu__item-cost\">Цена:</div>\r\n\t\t\t\t\t<div class=\"menu__item-total\"><span>${this.price}</span> руб./день</div>\r\n\t\t\t\t</div>\t\t\t\t\r\n\t\t\t`;\r\n\t\t\tthis.parentSelector.append(element); // метод append() добавляет в container новый element\t\t\t\t\r\n\t\t\t// console.log(this.classes);\r\n\t\t}\r\n\t}\r\n\t// getResources('http://localhost:3000/menu') => еще вариант формирования MenuCards\r\n\t// \t.then(data => createMenuCards(data));\r\n\t// function createMenuCards(data) {\r\n\t// \tdata.forEach(({img, altimg, title, descr, price}) => {\r\n\t// \t\tconst element = document.createElement('div');\r\n\t// \t\telement.classList.add('menu__item');\r\n\t// \t\telement.innerHTML = `\t\t\t\t\t\r\n\t// \t\t\t<img src=${img} alt=${altimg}>\r\n\t// \t\t\t<h3 class=\"menu__item-subtitle\">${title}</h3>\r\n\t// \t\t\t<div class=\"menu__item-descr\">${descr}</div>\r\n\t// \t\t\t<div class=\"menu__item-divider\"></div>\r\n\t// \t\t\t<div class=\"menu__item-price\">\r\n\t// \t\t\t\t<div class=\"menu__item-cost\">Цена:</div>\r\n\t// \t\t\t\t<div class=\"menu__item-total\"><span>${price}</span> руб./день</div>\r\n\t// \t\t\t</div>\t\t\t\r\n\t// \t\t`;\r\n\t// \t\tdocument.querySelector('.menu .container').append(element);\r\n\t// \t});\r\n\t// }\r\n\tgetResources('http://localhost:3000/menu') // оптимизируем работу с карточками МЕНЮ\r\n\t\t.then(data => {\r\n\t\t\tdata.forEach(({img, altimg, title, descr, price}) => { // перебираем весь массив db.json состоящий из объектов деструктурировав его методом ({img, altimg, title, descr, price})\r\n\t\t\t\tnew MenuCards(img, altimg, title, descr, price, '.menu .container').render(); // запускаем конструктор - MenuCards() для заполнения - render() карточек меню столько раз, сколько объектов в массиве db.json\r\n\t\t\t});\r\n\t\t});\r\n\t// new MenuCards(    => заменили верстку динамическим формированием MenuCards с помощью запросов к серверу\r\n\t// \t'img/tabs/vegy.jpg',\r\n\t// \t'vegy',\r\n\t// \t'Меню \"Фитнес\"',\r\n\t// \t'Меню \"Фитнес\" - это новый подход к приготовлению блюд: больше свежих овощей и фруктов. Продукт активных и здоровых людей. Это абсолютно новый продукт с оптимальной ценой и высоким качеством!',\r\n\t// \t9,\r\n\t// \t'.menu .container',\r\n\t// \t'menu__item',  // классы успешно добавляются\r\n\t// \t// 'first', // классы успешно добавляются\r\n\t// \t// 'first__green', // классы успешно добавляются\r\n\t// ).render(); // заполняем новый класс MenuCards с помощью метода render()\r\n\t// new MenuCards(\r\n\t// \t'img/tabs/elite.jpg',\r\n\t// \t'elite',\r\n\t// \t'Меню \"Премиум\"',\r\n\t// \t'В меню \"Премиум\" мы используем не только красивый дизайн упаковки, но и качественное исполнение блюд. Красная рыба, морепродукты, фрукты - ресторанное меню без похода в ресторан!',\r\n\t// \t21,\r\n\t// \t'.menu .container',\r\n\t// \t'menu__item',  // классы успешно добавляются\r\n\t// \t// 'second', // классы успешно добавляются\r\n\t// \t// 'second__blue', // классы успешно добавляются\r\n\t// ).render(); // заполняем новый класс MenuCards с помощью метода render()\r\n\t// new MenuCards(\r\n\t// \t'img/tabs/post.jpg',\r\n\t// \t'post',\r\n\t// \t'Меню \"Постное\"',\r\n\t// \t'Меню \"Постное\" - это тщательный подбор ингредиентов: полное отсутствие продуктов животного происхождения, молоко из миндаля, овса, кокоса или гречки, правильное количество белков за счет тофу и импортных вегетарианских стейков.',\r\n\t// \t14,\r\n\t// \t'.menu .container',\r\n\t// \t'menu__item',  // классы успешно добавляются\r\n\t// \t// 'third', // классы успешно добавляются\r\n\t// \t// 'third__red',  // классы успешно добавляются\r\n\t// ).render(); // заполняем новый класс MenuCards с помощью метода render()\r\n}","/* eslint-disable linebreak-style */\r\nexport default function carousel({container, slide, nextArrow, prevArrow, totalCounter, currentCounter, wrapper, field}) { // принцип деструктуризации, создаем объект аргументов\r\n\t// SLIDER----------------------ПРОСТОЙ ВАРИАНТ--------------------\r\n\t// const slides = document.querySelectorAll('.offer__slide'); // получаем все слайды на странице\r\n\t// const prev = document.querySelector('.offer__slider-prev'); // получаем стрелки перелистывания слайдов\r\n\t// const next = document.querySelector('.offer__slider-next'); // получаем стрелки перелистывания слайдов\r\n\t// const totalSlides = document.querySelector('#total'); // получаем значение элементов по идентификатору\r\n\t// const currentSlide = document.querySelector('#current'); // получаем значение элемента по идентификатору\r\n\t// let slideIndex = 1; // назначаем индекс каждому слайду\r\n\t// showSlides(slideIndex); // инициализируем функцию showSlides() со значением \"1\"\r\n\t// if (slides.length < 10) { // если количество слайдов меньше\r\n\t// \ttotalSlides.textContent = `0${slides.length}`; // то добавляем к порядковому значению слайда \"0\"\r\n\t// } else { // иначе\r\n\t// \ttotalSlides.textContent = slides.length; // просто записываем порядковое значение слайда\r\n\t// }\r\n\t// function showSlides(n)  { // присваиваем порядковый номер каждому слайду \"n\"\r\n\t// \tif (n > slides.length) {// если количество слайдов slides.length меньше порядкового номера слайда \"n\"\r\n\t// \t\tslideIndex = 1; // если ушли в \"правую границу\" слайдов, то перемещаемся в самое \"начало\" => slideIndex = 1\r\n\t// \t}\r\n\t// \tif (n < 1) {// если порядковый номер слайда \"n\" меньше 1\r\n\t// \t\tslideIndex = slides.length; // если ушли в \"левую границу\" слайдов, то перемещаемся в самый \"конец\" => slideIndex = slides.length\r\n\t// \t}\r\n\t// \tslides.forEach(item => item.style.display = 'none'); // сначала скрываем все слайды на страничке\r\n\t// \tslides[slideIndex - 1].style.display = 'block' ; // потом по нажатию показываем нужный слайд, выбираем [slideIndex - 1] так как массив начинается с \"0\"\r\n\t// \tif (slides.length < 10) { // если количество слайдов меньше\r\n\t// \t\tcurrentSlide.textContent = `0${slideIndex}`; // то добавляем к порядковому значению слайда \"0\"\r\n\t// \t} else { // иначе\r\n\t// \t\tcurrentSlide.textContent = slideIndex; // просто записываем порядковое значение слайда\r\n\t// \t}\r\n\t// }\r\n\t// function plusSlide(n) { // перебираем слайды по нажатию на стрелочки\r\n\t// \tshowSlides(slideIndex += n); // если n=1, то прибавляем, если n=-1, то отнимаем \r\n\t// }\r\n\t// prev.addEventListener('click', () => { // при нажатии на стрелочку \"влево\", передаем в функцию plusSlide() минус один\r\n\t// \tplusSlide(-1);\r\n\t// });\r\n\t// next.addEventListener('click', () => { // при нажатии на стрелочку \"вправо\", передаем в функцию plusSlide() плюс один\r\n\t// \tplusSlide(1);\r\n\t// });\r\n\t\r\n\t// CAROUSEL-------------------------------------БОЛЕЕ СЛОЖНЫЙ ВАРИАНТ------------\r\n\tconst slides = document.querySelectorAll(slide); // получаем все слайды на странице (length: 4)\r\n\tconst slider = document.querySelector(container); // получаем весь блок слайдера\r\n\tconst prev = document.querySelector(prevArrow); // получаем стрелки перелистывания слайдов\r\n\tconst next = document.querySelector(nextArrow); // получаем стрелки перелистывания слайдов\r\n\tconst totalSlides = document.querySelector(totalCounter); // получаем общее значение элементов по идентификатору\r\n\tconst currentSlide = document.querySelector(currentCounter); // получаем текущее значение элемента по идентификатору\r\n\tconst slidesWrapper = document.querySelector(wrapper); // получаем блок-обертку слайдеров\r\n\tconst sliderInner = document.querySelector(field); // получаем дополнительно созданный блок, объединяющий в линию все слайды\r\n\tconst sliderWidth = window.getComputedStyle(slidesWrapper).width; // получаем значение ширины слайдера из блока-обёртки слайдов (применим для расчета ширины одного слайда) = 650px\r\n\tlet slideIndex = 1; // назначаем индекс каждому слайду\t\r\n\tlet slideOffset = 0; // назначим отступ как ориентир сдвига слайдов\r\n\tif (slides.length < 10) { // если количество слайдов меньше\r\n\t\ttotalSlides.textContent = `0${slides.length}`; // то добавляем к порядковому значению слайда \"0\"\r\n\t\tcurrentSlide.textContent = `0${slideIndex}`;\r\n\t} else { // иначе\r\n\t\ttotalSlides.textContent = slides.length; // просто записываем порядковое значение слайда\r\n\t\tcurrentSlide.textContent = slideIndex;\r\n\t}\r\n\tsliderInner.style.width = 100 * slides.length + '%'; // 100% значение ширины блока offer__slide умножаем на количество слайдов slides.length (это запись css стилей), чтобы слайды помещались в блок offer__slider-inner (получаем 400%)\r\n\tsliderInner.style.display = 'flex'; // присваиваем CSS свойства блоку offer__slider-inner для того, чтобы слайды выстроились в строку\r\n\tsliderInner.style.transition = '0.5s all'; // присваиваем CSS свойства блоку offer__slider-inner для того, чтобы слайды перемещались плавно\r\n\tslidesWrapper.style.overflow = 'hidden'; // ограничим отображение сверх блока offer__slider-wrapper\r\n\tslides.forEach(slide => { // ограничим ширину всех слайдов, обратившись к каждому слайду на странице, установив определенную ширину\r\n\t\tslide.style.width = sliderWidth; // получаем значение 650px\r\n\t});\r\n\tslider.style.position = 'relative'; // присваиваем значение всему блоку offer__slider\r\n\tconst dots = document.createElement('ol'); // создаем переменную dots для навигации по слайдеру в блоке ol нумерованного списка\r\n\tconst dotsArr = []; // создаем массив для навигации по слайдеру (length: 4) [li, li, li, li]\r\n\tdots.classList.add('carousel-dots'); // добавляем в блок ol нумерованного списка класс carousel-dots и CSS стили\r\n\tdots.style.cssText = `\r\n\t\tposition: absolute;\r\n\t\tright: 0;\r\n\t\tbottom: 0;\r\n\t\tleft: 0;\r\n\t\tz-index: 15;\r\n\t\tdisplay: flex;\r\n\t\tjustify-content: center;\r\n\t\tmargin-right: 15%;\r\n\t\tmargin-left: 15%;\r\n\t\tlist-style: none;\r\n\t`;\r\n\tslider.append(dots); // добавляем в слайдер блок ol нумерованного списка\r\n\tfor (let i = 0; i < slides.length; i++) { // добавляем итератор +1 для всего количества слайдов\r\n\t\tconst dot = document.createElement('li'); // каждому li - элементу нумерованного списка назначаем =>\r\n\t\tdot.setAttribute('data-slide-to', i + 1); // дата атрибут, т.е. нумерацию (массив начинается с нуля + 1, значит пойдет с единицы) и CSS стили\r\n\t\tdot.style.cssText = `\r\n\t\t\tbox-sizing: content-box;\r\n\t\t\tflex: 0 1 auto;\r\n\t\t\twidth: 30px;\r\n\t\t\theight: 6px;\r\n\t\t\tmargin-right: 3px;\r\n\t\t\tmargin-left: 3px;\r\n\t\t\tcursor: pointer;\r\n\t\t\tbackground-color: #fff;\r\n\t\t\tbackground-clip: padding-box;\r\n\t\t\tborder-top: 10px solid transparent;\r\n\t\t\tborder-bottom: 10px solid transparent;\r\n\t\t\topacity: .5;\r\n\t\t\ttransition: opacity .6s ease;\r\n\t\t`;\r\n\t\tif (i == 0) { // если первая итерация =>\r\n\t\t\tdot.style.opacity = 1; // то к первому dot добавляем класс активности (opacity) непрозрачность\r\n\t\t}\r\n\t\tdots.append(dot); // добавляем в слайдер и в блок ol нумерованного списка, навигационные кнопки нумерованного списка\r\n\t\tdotsArr.push(dot); // связываем массив с точками(элементами) нумерованного списка в слайдере (push - добавлять в массив)\r\n\t}\r\n\tfunction deleteNotDigits(str) { // оптимизируем код одной функцией\r\n\t\treturn +str.replace(/\\D/g, ''); // замещаем в строке (+str) с числовым типом данных все нецифры (\\D) с глобальным флагом (g) на пустое место сроки, т.е. 650px => 650\r\n\t}\r\n\tfunction changeIndexСondition() { // оптимизируем код одной функцией с условием\r\n\t\tif (slides.length < 10) {\r\n\t\t\tcurrentSlide.textContent = `0${slideIndex}`;\r\n\t\t} else {\r\n\t\t\tcurrentSlide.textContent = slideIndex;\r\n\t\t}\r\n\t}\r\n\tfunction changeDotСondition() { // оптимизируем код одной функцией\r\n\t\tdotsArr.forEach(dot => dot.style.opacity = '.5');\r\n\t\tdotsArr[slideIndex - 1].style.opacity = 1;\r\n\t}\r\n\tprev.addEventListener('click', () => { // при нажатии на стрелочку \"влево\",  смещаем слайд вправо на плюсовое значение slideOffset\r\n\t\tif (slideOffset == 0) { // после сравнения и выяснения, что у нас возвращен первый слайд, перемещаемся в самый конец\r\n\t\t\tslideOffset = deleteNotDigits(sliderWidth) * (slides.length - 1); // т.е. долистываем до самого начала блока слайдов и переключаемся на последний слайд - отступ равен ширине одного слайда (из строки '650px' с длинной символов 5 - вырезаем последние два) умноженного на (число слайдов минус один) = 1950\r\n\t\t\tsliderInner.style.transition = '0.25s all';\r\n\t\t} else {\r\n\t\t\tslideOffset -= deleteNotDigits(sliderWidth); // по нажатию срелочки \"влево\", к -slideOffset добавляется ширина еще одного слайда и слайд смещается на определенную величину\r\n\t\t\tsliderInner.style.transition = '0.5s all';\r\n\t\t}\r\n\t\tsliderInner.style.transform = `translateX(-${slideOffset}px)`; // сдвигаем слайд с помощью transform: translateX(), так как значение плюсовое - сдвиг вправо \r\n\t\tif (slideIndex == 1) { // если текущий slideIndex равен 1 \r\n\t\t\tslideIndex = slides.length; // присваиваем значение slideIndex количество слайдов\r\n\t\t} else {\r\n\t\t\tslideIndex--; // иначе уменьшаем на единицу\r\n\t\t}\r\n\t\tchangeIndexСondition();\r\n\t\tchangeDotСondition();\r\n\t});\r\n\tnext.addEventListener('click', () => { // при нажатии на стрелочку \"вправо\", смещаем слайд влево на минусовое значение slideOffset \r\n\t\tif (slideOffset == deleteNotDigits(sliderWidth) * (slides.length - 1)) { // отступ равен ширине одного слайда (из строки '650px' с длинной символов 5 - вырезаем последние два) умноженного на (число слайдов минус один)\r\n\t\t\tsliderInner.style.transition = '0.25s all';\r\n\t\t\tslideOffset = 0; // т.е. долистываем до самого конца блока слайдов и переключаемся на первый слайд\r\n\t\t} else {\r\n\t\t\tsliderInner.style.transition = '0.5s all';\r\n\t\t\tslideOffset += deleteNotDigits(sliderWidth); // когда мы нажимаем срелочку \"вправо\", к +slideOffset добавляется ширина еще одного слайда и слайд смещается на определенную величину\r\n\t\t}\r\n\t\tsliderInner.style.transform = `translateX(-${slideOffset}px)`; // сдвигаем слайд с помощью transform: translateX(), так как значение минусовое - сдвиг влево \r\n\t\tif (slideIndex == slides.length) { // если текущий slideIndex равен количеству слайдов\r\n\t\t\tslideIndex = 1; // присваиваем значение slideIndex единицу\r\n\t\t} else {\r\n\t\t\tslideIndex++; // иначе увеличиваем на единицу\r\n\t\t}\r\n\t\tchangeIndexСondition();\r\n\t\tchangeDotСondition();\r\n\t});\r\n\tdotsArr.forEach(dot => {\r\n\t\tdot.addEventListener('click', (e) => { // назначаем каждой из точек событие\r\n\t\t\tconst slideTo = e.target.getAttribute('data-slide-to'); // присваиваем переменной slideTo новый атрибут data-slide-to\r\n\t\t\tslideIndex = slideTo; // присваиваем переменной slideIndex значение slideTo\r\n\t\t\tslideOffset = deleteNotDigits(sliderWidth) * (slideTo - 1);\r\n\t\t\tsliderInner.style.transform = `translateX(-${slideOffset}px)`;\r\n\t\t\tchangeIndexСondition();\r\n\t\t\tchangeDotСondition();\r\n\t\t});\r\n\t});\r\n}","/* eslint-disable linebreak-style */\r\nimport {openModalWindow, closeModalWindow} from './modal.js';\r\nimport {postData} from '../services/services.js';\r\n\r\n// SEND-FORMS---------fetch() НОВЫЙ ТИП ЗАПРОСОВ гораздо ПРОЩЕ и КОРОЧЕ \r\nexport default function forms(formSelector, modalTimerId) {\r\n\tconst forms = document.querySelectorAll(formSelector);\r\n\tconst message = {\r\n\t\t// loading: 'Загрузка...', // текст комментируем, так как будем использовать спиннер картинку\r\n\t\tloading: 'img/form/spinner.svg', // добавляем картинку спиннера вместо надписи в блоке div Загрузка...\r\n\t\tsuccess: 'Спасибо! Скоро с Вами свяжемся!',\r\n\t\tfailure: 'Что-то пошло не так...',\r\n\t};\r\n\tforms.forEach(item => { // берем все созданные формы и подвязываем функцию bindpostData\r\n\t\tbindPostData(item);\r\n\t});\r\n\tfunction bindPostData(form) { // будем (bind) привязывать какую-то форму, очень удобно навесить на нее обработчик события submit, которое будет срабатывать каждый раз при отправке форм\r\n\t\tform.addEventListener('submit', (e) => {\r\n\t\t\te.preventDefault(); // отменяем дефолтную перезагрузку и поведение браузера\r\n\t\t\t// const statusMessage = document.createElement('div'); // создаем блок для сообщений\r\n\t\t\tconst statusMessage = document.createElement('img'); // вместо блока теперь будем использовать картинку спиннера\r\n\t\t\t// statusMessage.classList.add('status'); // добавляем класс блоку сообщений\r\n\t\t\tstatusMessage.src = message.loading; // используем путь к спиннеру\r\n\t\t\tstatusMessage.textContent = message.loading; // заполняем блок главным сообщением 'Загрузка...'\r\n\t\t\tstatusMessage.style.cssText = `\r\n\t\t\t\tdisplay: block;\r\n\t\t\t\tmargin: 0 auto;\r\n\t\t\t`; // добавляем стили спиннеру\r\n\t\t\t// form.append(statusMessage); // к форме добавляем это сообщение 'Загрузка...'\r\n\t\t\tform.insertAdjacentElement('afterend', statusMessage); // чтобы спиннер не сбивал верстку используем insertAdjacentElement() - вставить соседний элемент ()!!!\r\n\t\t\tconst formData = new FormData(form); // FormData(form) отыскивает в html атрибут name в тегах input всех форм, без него работать не будет!!!\r\n\t\t\t// const objectJson = {}; // создал новый объект для отправки данных в формате json\r\n\t\t\t// formData.forEach(function(value, key) { // forEach переберет все, что есть внутри formData и заполнит objectJson\r\n\t\t\t// \tobjectJson[key] = value;\r\n\t\t\t// });\r\n\t\t\t// postData('http://localhost:3000/requests', JSON.stringify(objectJson)) // конвертируем оson в строку JSON с двойными ковычками =>\r\n\t\t\t// это упрощеная форма создания объекта objectJson, есть более элегантый способ  с помощью методов Json => берем formData и превращаем ее в массив массивов с помощью formData.entries(), \r\n\t\t\tconst json = JSON.stringify(Object.fromEntries(formData.entries())); // далее в классический объект Object.fromEntries(formData.entries(), а затем, переводим в формат JSON данные запроса через JSON.stringify(Object.fromEntries(formData.entries()))\t\t\t\r\n\t\t\tpostData('http://localhost:3000/requests', json)\r\n\t\t\t// .then(data => data.text()) // данная строка уже не нужна, она создается в postData асинхронной функции и уже там прописана внутри\r\n\t\t\t\t.then(data => { // сервер вернет данные data, пока это не JSON\r\n\t\t\t\t\tconsole.log(data); // берем data данные, которые вернул сервер из PROMISE (успешный исход)\r\n\t\t\t\t\tshowThanksModal(message.success); // вместо statusMessage.textContent будет показываться модальное окно функции showThanksModal()!!!\r\n\t\t\t\t\tstatusMessage.remove(); // удаляем наш спинер по выполнению PROMISE\r\n\t\t\t\t}).catch(() => { // catch метод обязательно нужно прописывать для обратоток ошибок!!!\r\n\t\t\t\t\tshowThanksModal(message.failure);// вместо statusMessage.textContent будет показываться модальное окно функции showThanksModal()!!!\t\t\t\t\r\n\t\t\t\t}).finally(() => { // finally метод обязательно нужно прописывать для обратоток оконечных действий\r\n\t\t\t\t\tform.reset(); // очищаем форму после выведением сообщения\t\t\t\t\r\n\t\t\t\t});\r\n\t\t}); \r\n\t}\r\n\tfunction showThanksModal(message) { // создаем функцию динамической замены элементов мадального окна с отправкой сообщения message\r\n\t\tconst prevModalDialog = document.querySelector('.modal__dialog'); // получаем элемент modal__dialog\r\n\t\tprevModalDialog.classList.add('hide'); // добавляем класс hide элементу modal__dialog\r\n\t\topenModalWindow('.modal', modalTimerId); // команда открытия модальных окон\r\n\t\tconst thanksModal = document.createElement('div'); // создаем новый контент обертку\r\n\t\tthanksModal.classList.add('modal__dialog'); // будем заменять один modal__dialog другим с новым контентом\r\n\t\tthanksModal.innerHTML = ` \r\n\t\t\t<div class=\"modal__content\">\r\n\t\t\t\t<div class=\"modal__close\" data-close>&times;</div>\r\n\t\t\t\t<div class=\"modal__title\">${message}</div>\r\n\t\t\t</div>\r\n\t\t`; // создаем новый контент и в первоначальном скрипте (MODAL----) настраиваем ДЕЛЕГИРОВАНИЕ СОБЫТИЙ!!!\r\n\t\tdocument.querySelector('.modal').append(thanksModal); // помещаем новое модальное окно на страницу\r\n\t\tsetTimeout(() => { // чтобы новый динамический блок исчезал через 4 сек. и появлялся предыдущий сверстанный блок modal__dialog, применим асинхронную операцию setTimeout()\r\n\t\t\tthanksModal.remove(); // thanksModal будем удалять, чтобы вновь созданные блоки не накапливались\r\n\t\t\tprevModalDialog.classList.add('show'); // заменяем классы отображения сверстанного модального окна modal__dialog\r\n\t\t\tprevModalDialog.classList.remove('hide');\r\n\t\t\tcloseModalWindow('.modal'); // закрываем модальное окно, чтобы не мешать пользователю\r\n\t\t}, 4000);\r\n\t}\r\n}","/* eslint-disable linebreak-style */\r\n\r\nfunction openModalWindow(modalSelector, modalTimerId) {\r\n\tconst modalWindow = document.querySelector(modalSelector);\r\n\tmodalWindow.classList.add('show');\r\n\tmodalWindow.classList.remove('hide');\r\n\tdocument.body.style.overflow = 'hidden'; // при открытии модального окна, скрываем скролл страницы\r\n\tconsole.log(modalTimerId);\r\n\tif (modalTimerId) { // если modalTimerId был передан, то только тогда будет запускаться clearInterval()\r\n\t\tclearInterval(modalTimerId); // если пользователь сам зарыл модальное окно, сбрасываем интервал его автооткрытия\r\n\t}\t\r\n} \r\nfunction closeModalWindow(modalSelector) {\r\n\tconst modalWindow = document.querySelector(modalSelector);\r\n\tmodalWindow.classList.add('hide');\r\n\tmodalWindow.classList.remove('show');\r\n\tdocument.body.style.overflow = ''; // при закрытии модального окна, включаем скролл страницы\r\n}\r\n\r\n// MODAL----------------------------------------------------------\r\nfunction modal(triggerSelector, modalSelector, modalTimerId) { // добавим длва аргумента triggerSelector, modalSelector для инкапсуляции \r\n\tconst modalTrigger = document.querySelectorAll(triggerSelector);\r\n\tconst modalWindow = document.querySelector(modalSelector);\r\n\t// const modalCloseBtn = document.querySelector('[data-close]'); // для ДЕЛЕГИРОВАНИЯ СОБЫТИЙ убираем данную переменную\r\n\tmodalTrigger.forEach(btn => {\r\n\t\tbtn.addEventListener('click', () => openModalWindow(modalSelector, modalTimerId)); // переданная в обработчик события коллбэк функция openModalWindow(modalSelector)) не дожна сразу вызываться, а просто объявляться, () => стрелочная функция оборачивает коллбэк и вызывает его по клику\r\n\t});\r\n\t// modalCloseBtn.addEventListener('click', closeModalWindow); // для ДЕЛЕГИРОВАНИЯ СОБЫТИЙ убираем данную часть\r\n\tmodalWindow.addEventListener('click', (e) => {\r\n\t\tif (e.target === modalWindow || e.target.getAttribute('data-close') == '') { // если по клику целевое событие совпадает с модальным окном, то модальное окно закрывается\r\n\t\t\tcloseModalWindow(modalSelector);\t// для ДЕЛЕГИРОВАНИЯ СОБЫТИЙ добавляем условие  || e.target.getAttribute('data-close') == '' т.е. когда в елементе есть data-close со значение пустой строки, кликаем на подложку или крестик - окно закрывается\t\t\r\n\t\t}\r\n\t});\r\n\tdocument.addEventListener('keydown', (e) => {\r\n\t\tif (e.code === 'Escape' && modalWindow.classList.contains('show')) { // по клавише ESC закрывается окно\r\n\t\t\tcloseModalWindow(modalSelector);\r\n\t\t}\r\n\t});\r\n\tfunction showModalWindowByScroll() {\r\n\t\tif (window.scrollY + document.documentElement.clientHeight >= document.documentElement.scrollHeight) { // отслеживаем сколько пикселей по оси Y отлистал пользователь + высота видимой части сравниваются с высотой/прокруткой всего контента\r\n\t\t\topenModalWindow(modalSelector, modalTimerId); // если они совпадают, то пользователь долистал до конца контена => открывается модальное окно, но при каждом долистовании!!!\r\n\t\t\twindow.removeEventListener('scroll', showModalWindowByScroll); // как только пользователь долистал до конца, модальное окно выйдет только ОДИН РАЗ!!!! УДАЛЯЕМ ОБРАБОТЧИК!!!\r\n\t\t} // нужно избежать подобных повторов, но =>\r\n\t} // }, {once: true}); в данном случае не подходит, так как единоразовая прокрутка на 1px вызывает это условие!!!\r\n\twindow.addEventListener('scroll', showModalWindowByScroll); // отслеживаем событие scroll во всем окне браузера\r\n}\r\nexport default modal;\r\nexport {openModalWindow};\r\nexport {closeModalWindow};","/* eslint-disable linebreak-style */\r\n// TABS-----------------------------------------------------------\r\nexport default function tabs(tabsSelector, tabsContentSelector, tabsParentSelector, activeClass) {\r\n\tconst tabs =  document.querySelectorAll(tabsSelector);\r\n\tconst tabsContent = document.querySelectorAll(tabsContentSelector);\r\n\tconst tabsParent = document.querySelector(tabsParentSelector);\r\n\tfunction hideTabContent() { // функция скрывает часть табов\r\n\t\ttabsContent.forEach(item => {\r\n\t\t\t// item.style.display = 'none';\r\n\t\t\titem.classList.add('hide');\r\n\t\t\titem.classList.remove('show', 'fade');\r\n\t\t});\r\n\t\ttabs.forEach(item => {\r\n\t\t\titem.classList.remove(activeClass);\r\n\t\t});\r\n\t}\r\n\tfunction showTabContent(i = 0) { // ES6 позволяет по умолчанию задать значение аргумента в \"0\"!!!\r\n\t\t// tabsContent[i].style.display = 'block';\r\n\t\ttabsContent[i].classList.add('show', 'fade');\r\n\t\ttabsContent[i].classList.remove('hide');\r\n\t\ttabs[i].classList.add(activeClass);\r\n\t}\r\n\thideTabContent();\r\n\tshowTabContent();\r\n\ttabsParent.addEventListener('click', (event) => {\r\n\t\tconst target = event.target; // ЧАСТОЕ ИСПОЛЬЗОВАНИЕ event.target УДОБНО ПЕРЕОПРЕДЕЛИТЬ В ПЕРЕМЕННУЮ!!!\r\n\t\tif (target && target.classList.contains(tabsSelector.slice(1))) { // убираем точку у селектора '.tabheader__item'\r\n\t\t\ttabs.forEach((item, i) => { // для каждого элемента item (tab) с номером i в массиве\r\n\t\t\t\tif (target == item) { // если целевое событие соответствует этому элементу по клику\r\n\t\t\t\t\thideTabContent();\r\n\t\t\t\t\tshowTabContent(i); // при переключении tab скрываем остальные\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t});\r\n}","/* eslint-disable linebreak-style */\r\n// TAIMER-(обратного отсчета)-------------------------------------\r\nexport default function timer(id, deadLine) {\r\n\t// const deadLine = '2023-12-31'; // переводим в миллисекунды строку, создав новую переменную в виде строки... setClock('.timer', deadLine);\r\n\tfunction getTimeRemaining(endTime) { // функция оставшегося времени определяет разницу между deadLine (endTime) и текущим временем (new Date())\r\n\t\tconst t = Date.parse(endTime) - Date.parse(new Date()); // метод Date.parse - переводит строку в миллисекунды\r\n\t\tconst days = Math.floor(t / (1000 * 60 * 60 * 24)); // Math.floor - округление до ближайшего целого (миллисек * сек * мин * час в сутках)!\r\n\t\tconst hours = Math.floor((t / (1000 * 60 * 60) % 24)); // % - остаток от деления, например 50 / 24 = 2 дня и 2 часа, возвращаем 2 часа!\r\n\t\tconst minutes = Math.floor((t / 1000 / 60) % 60);\r\n\t\tconst seconds = Math.floor((t / 1000) % 60);\r\n\t\treturn { // создаем объект!!!\r\n\t\t\t'total': t,\r\n\t\t\t'days': days,\r\n\t\t\t'hours': hours,\r\n\t\t\t'minutes': minutes,\r\n\t\t\t'seconds': seconds,\r\n\t\t};\r\n\t}\r\n\tfunction getZero(num) { // функция подставления 0 до двузначного числа!!!\r\n\t\tif (num >= 0 && num < 10) {\r\n\t\t\treturn `0${num}`;\r\n\t\t} else {\r\n\t\t\treturn num;\r\n\t\t}\r\n\t}\r\n\tfunction setClock(selector, endTime) {\r\n\t\tconst timer = document.querySelector(selector); // это div.timer так как setClock('.timer', deadLine);\r\n\t\tconst days = timer.querySelector('#days');\r\n\t\tconst hours = timer.querySelector('#hours');\r\n\t\tconst minutes = timer.querySelector('#minutes');\r\n\t\tconst seconds = timer.querySelector('#seconds');\r\n\t\tconst timeInterval = setInterval(updateClock, 1000); // функция updateClock будет запускаться каждые 1000 миллисекунд\r\n\t\tupdateClock(); // функция запускается один раз первоначально, для избежания мигания таймера, потом устанавливается setInterval в 1000 миллисекунд\r\n\t\tfunction updateClock () { // расчет времени на данную секунду, разница между планируемым временем и текущим\r\n\t\t\tconst t = getTimeRemaining(endTime); // расчет времени запишется на страницу\r\n\t\t\tdays.innerHTML = getZero(t.days);\r\n\t\t\thours.innerHTML = getZero(t.hours);\r\n\t\t\tminutes.innerHTML = getZero(t.minutes);\r\n\t\t\tseconds.innerHTML = getZero(t.seconds);\r\n\t\t\tif (t.total <= 0) {\r\n\t\t\t\tclearInterval(timeInterval); // останавливаем таймер как только время выйдет, когда (new Date()) будет больше (endTime)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tsetClock(id, deadLine);\r\n}","/* eslint-disable linebreak-style */\r\nconst postData = async (url, data) => { // function expression -  без объявления присваивается в переменную, postData отвечает за постинг данных при отправке на сервер + async в связи с асинхронностью выполнения\r\n\tconst result = await fetch(url, { // в fetch(), url - указываем первым аргументом адрес сервера, data - данные, которые будут поститься - т.е. отправляем сформированный запрос + await для ожидания ответа от сервера\r\n\t\tmethod: 'POST',\r\n\t\theaders: {\r\n\t\t\t'Content-type': 'application/json' \r\n\t\t},\r\n\t\tbody: data,\t// создаем новый объект для формирования документа запроса fetch(), метод и заголовки указывать обязательно!!!\t\r\n\t}); // фетч запрос вернет промис, в переменной result нет ничего, пока промис не вернет от сервера данные\r\n\treturn await result.json(); // возвращаем из функции postData промис (result.json()) для дальнейшей обработки через чепочку .then() - но это АСИНХРОННЫЙ КОД + await дожидается обработки данных в result.json()!!!\r\n};\r\nconst getResources = async (url) => { // function expression - без объявления присваивается в переменную, getResources отвечает за получение данных с сервера + async в связи с асинхронностью выполнения\r\n\tconst result = await fetch(url); // фетч запрос вернет промис, в переменной result нет ничего, пока промис не вернет от сервера данные, но fetch сигналы 404, 403, 401 не распознает как ОШИБКИ!!! \r\n\t// ошибками для него являются отсутствие Интернета или критические неполадки в запросе!!! Поэтому создаем условие на сравнение:\r\n\tif (!result.ok) { // если с result что-то не то.... то\r\n\t\tthrow new Error(`Could not fetch ${url}, status: ${result.status}`); // то выбрасываем новыю ошибку\r\n\t}\r\n\treturn await result.json(); // возвращаем из функции postData промис (result.json()) для дальнейшей обработки через чепочку .then() - но это АСИНХРОННЫЙ КОД + await дожидается обработки данных в result.json()!!!\r\n};\r\nexport {postData};\r\nexport {getResources};","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/* eslint-disable linebreak-style */\r\nimport tabs from './modules/tabs.js';\r\nimport cards from './modules/cards.js';\r\nimport timer from './modules/timer.js';\r\nimport modal from './modules/modal.js';\r\nimport forms from './modules/forms.js';\r\nimport carousel from './modules/carousel.js';\r\nimport calculator from './modules/calculator.js';\r\nimport {openModalWindow} from './modules/modal.js';\r\n\r\nwindow.addEventListener('DOMContentLoaded', () => {\r\n\tconst modalTimerId = setTimeout(() => openModalWindow('.modal', modalTimerId), 60000); // функция автооткрытия модального окна\r\n\r\n\t// TABS-----------------------------------------------------------\r\n\ttabs('.tabheader__item', '.tabcontent', '.tabheader__items', 'tabheader__item_active');\r\n\r\n\t// TAIMER-(обратного отсчета)-------------------------------------\r\n\ttimer('.timer', '2024-01-25');\r\n\r\n\t// MODAL----------------------------------------------------------\t\r\n\tmodal('[data-modal]', '.modal', modalTimerId);\r\n\r\n\t// CLASSES-for-CARDS----------------------------------------------\r\n\tcards();\r\n\r\n\t// SEND-FORMS----fetch() НОВЫЙ ТИП ЗАПРОСОВ гораздо ПРОЩЕ и КОРОЧЕ\r\n\tforms('form', modalTimerId);\r\n\r\n\t// SLIDER----------------------ПРОСТОЙ ВАРИАНТ--------------------\r\n\tcarousel({ // принцип деструктуризации, создаем объект аргументов\r\n\t\tcontainer: '.offer__slider',\r\n\t\tslide: '.offer__slide',\r\n\t\tnextArrow: '.offer__slider-next',\r\n\t\tprevArrow: '.offer__slider-prev',\r\n\t\ttotalCounter: '#total',\r\n\t\tcurrentCounter: '#current',\r\n\t\twrapper: '.offer__slider-wrapper',\r\n\t\tfield: '.offer__slider-inner',\r\n\t});\r\n\r\n\t// CALCULATOR-----------------------------------------------------\r\n\tcalculator();\r\n\r\n});"],"names":[],"sourceRoot":""}