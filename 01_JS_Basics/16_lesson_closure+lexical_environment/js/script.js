// ПЕРВОЕ ПРИЛОЖЕНИЕ!!!

'use strict';

// ЛЕКСИЧЕСКОЕ ОКРУЖЕНИЕ - ЭТО ВНУТРЕННИЙ ТЕХНИЧЕСКИ СКРЫТЫЙ ОБЪЕКТ КОДА, ПРИ ЭТОМ ОКРУЖЕНИЕ ДЕЛИТСЯ НА ВНУТРЕННЕЕ И ВНЕШНЕЕ!!!
// ВНУТРЕННЕЕ ЛЕКСИЧЕСКОЕ ОКРУЖЕНИЕ - ЭТО ОБЪЕКТ, В КОТОРОМ КАК СВОЙСТВА ХРАНЯТСЯ ВСЕ ЛОКАЛЬНЫЕ ПЕРЕМЕННЫЕ ЭТОЙ ФУНКЦИИ В ТОМ ЧИСЛЕ И THIS!!!
// ВНЕШНЕЕ ЛЕКСИЧЕСКОЕ ОКРУЖЕНИЕ - ЭТО КОД СНАРУЖИ ФУНКЦИИ!!!
// ЗАМЫКАНИЕ = ФУНКЦИЯ ПЫТАЕТСЯ НАЙТИ ПЕРЕМЕННЫЕ ВНУТРИ СЕБЯ, ПОТОМ ИДЕТ НА УРОВЕНЬ ВЫШЕ, В ГЛОБАЛЬНОЙ ОБЛАСТИ ВИДИМОСТИ!!!

// let number = 5; debugger;
// // logNumber(); // если вызвать функцию до объявления, то получим: 5, так как функция будет видеть переменную number = 5!!!
// function logNumber() { // переменная logNumber уже существует и имеет значение undefined, так как это объявленная функция, т.е. мы можем ее вызвать до ее объявления
// 	number = 4; debugger;  // если number объявить внутри функции, то получим: 4, так как функция будет видеть локальную переменную number = 4!!!
// 	console.log(number);
// }
// number = 6; // если вызвать функцию после объявления, то получим: 6, так как функция будет видеть переменную number = 5, а затем заменит данные на 6!!!
// // ФУНКЦИЯ БЕРЕТ ТЕКУЩЕЕ ЗНАЧЕНИЕ ПЕРЕМЕННЫХ ИЗ СВОЕГО ЛЕКСИЧЕСКОГО ОКРУЖЕНИЯ, СТАРЫЕ ПЕРЕМЕННЫЕ НЕ СОХРАНЯЮТСЯ
// // КАЖДЫЙ ВЫЗОВ ФУНКЦИИ - ЭТО СОЗДАНИЕ НОВОГО ЛЕКСИЧЕСКОГО ОКРУЖЕНИЯ СО СВОИМИ СПЕЦИФИЧНЫМИ ЛОКАЛЬНЫМИ ПЕРЕМЕННЫМИ И ПАРАМЕТРАМИ
// logNumber(); debugger;
// number = 10; // получим: 10
// logNumber(); debugger;

function createCounter() { // создаем функцию счетчика createCounter()
	let counter = 0; // создаем переменную счетчика counter со значением undefined и присваиваем ей 0 внутри createCounter(), при этом создается новое локальное лексическое окружение 
	const myFunction = function() { // создаем вложенное функциональное выражение в createCounter() со значением undefined и помещаем его в переменную myFunction
		counter = counter + 1; debugger; // создаем счетчик counter, прибавляющий + 1
		return counter; debugger; // возвращаем значение счетчика counter, в лексическом окружении будет храниться ссылка на переменную counter
	};
	return myFunction; // возвращаем через return функции счетчика createCounter() вложенное функциональное выражение myFunction (одна функция возвращает другую) =>
} // при этом внутреннее лексическое окружение myFunction будет уничтожено по выполнению return!!! Но, наружу возвращаем описание действий вложенного функционального выражения myFunction - это ее ЗАМЫКАНИЕ!!!
const increment = createCounter(); // помещаем в переменную increment со значением undefined функциональное выражение createCounter() с ее вызывом и возвращением функционального выражения myFunction
const c1 = increment(); debugger; // возвращенное значение функционального выражения myFunction в переменной increment присваиваем переменной c1, при вызове increment() создается новое лексическое окружение и запуск createCounter() 
const c2 = increment(); debugger; // возвращенное значение функционального выражения myFunction в переменной increment присваиваем переменной c2, при вызове increment() создается новое лексическое окружение и запуск createCounter()
const c3 = increment(); debugger; // возвращенное значение функционального выражения myFunction в переменной increment присваиваем переменной c3, при вызове increment() создается новое лексическое окружение и запуск createCounter()
console.log(c1, c2, c3);