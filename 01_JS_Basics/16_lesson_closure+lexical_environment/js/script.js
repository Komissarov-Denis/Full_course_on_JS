// ПЕРВОЕ ПРИЛОЖЕНИЕ!!!

'use strict';

// ЛЕКСИЧЕСКОЕ ОКРУЖЕНИЕ - ЭТО ВНУТРЕННИЙ ТЕХНИЧЕСКИ СКРЫТЫЙ ОБЪЕКТ КОДА, ПРИ ЭТОМ ОКРУЖЕНИЕ ДЕЛИТСЯ НА ВНУТРЕННЕЕ И ВНЕШНЕЕ!!!

// ВНУТРЕННЕЕ ЛЕКСИЧЕСКОЕ ОКРУЖЕНИЕ - ЭТО ОБЪЕКТ, В КОТОРОМ КАК СВОЙСТВА ХРАНЯТСЯ ВСЕ ЛОКАЛЬНЫЕ ПЕРЕМЕННЫЕ ЭТОЙ ФУНКЦИИ В ТОМ ЧИСЛЕ И THIS!!!

// ВНЕШНЕЕ ЛЕКСИЧЕСКОЕ ОКРУЖЕНИЕ - ЭТО КОД СНАРУЖИ ФУНКЦИИ!!!

// ЗАМЫКАНИЕ => ФУНКЦИЯ ПЫТАЕТСЯ НАЙТИ ПЕРЕМЕННЫЕ ВНУТРИ СЕБЯ, ПОТОМ ИДЕТ НА УРОВЕНЬ ВЫШЕ, В ГЛОБАЛЬНОЙ ОБЛАСТИ ВИДИМОСТИ!!!

// КАЖДЫЙ ВЫЗОВ ФУНКЦИИ - ЭТО СОЗДАНИЕ НОВОГО ЛЕКСИЧЕСКОГО ОКРУЖЕНИЯ СО СВОИМИ СПЕЦИФИЧНЫМИ ЛОКАЛЬНЫМИ ПЕРЕМЕННЫМИ И ПАРАМЕТРАМИ!!!

// ФУНКЦИЯ БЕРЕТ ТЕКУЩЕЕ/ПОСЛЕДНЕЕ ЗНАЧЕНИЕ ГЛОБАЛЬНЫХ/ЛОКАЛЬНЫХ ПЕРЕМЕННЫХ ИЗ СВОЕГО ЛЕКСИЧЕСКОГО ОКРУЖЕНИЯ, СТАРЫЕ ПЕРЕМЕННЫЕ НЕ СОХРАНЯЮТСЯ!!!

// let number = 5; debugger;
// // logNumber(); // если вызвать функцию до объявления, то получим: 5, так как функция будет видеть переменную number = 5!!!
// function logNumber() { // функция logNumber уже существует и имеет значение undefined, так как это объявленная функция, т.е. мы можем ее вызвать до ее объявления
// 	number = 4; debugger;  // если number объявить внутри функции, то получим: 4, так как функция будет видеть локальную переменную number = 4!!!
// 	console.log(number); // получил: 4
// }
// number = 6; // если вызвать функцию после объявления, то получим: 6, так как функция будет видеть переменную number = 5, потом заменит на 6, а затем заменит данные на 4!!!
// logNumber(); debugger;
// number = 10; // получим: 10, т.е. а затем заменит данные на 10!!!
// logNumber(); debugger;

// функция logNumber() работает так:
// на 1 шаге number = 5 (присваивается значение 5)
// на 2 шаге number = 5 (ссылка на глобальное значение 5, переход к глобальной переменной number = 6)
// на 3 шаге number = 6 (5 меняется на 6, переход к вызову функции logNumber())
// на 4 шаге logNumber() = undefined, number = 6 (вызывается функция logNumber() со значением undefined, переход к локальной number = 4, создается лексическое окружение)
// на 5 шаге logNumber() = undefined, number = 4 (глобальная переменная 6 меняется на локальную переменную 4)
// на 6 шаге console.log(number) = 4 (возвращается в консоль ссылка на расчитанное значение 4)
// на 7 шаге logNumber() = undefined, Вернуть значение: undefined, передается ссылка на значение локальных вычислений number = 4, удаляется лексическое окружение)
// на 8 шаге number = 4 (присваивается значение 4, переход к глобальной переменной number = 10)
// на 9 шаге number = 10 (4 меняется на 10)
// на 10 шаге number = 10 (переход к вызову функции logNumber())
// на 11 шаге logNumber() = undefined, number = 10 (вызывается функция logNumber() со значением undefined, переход к локальной number = 4, создается лексическое окружение)
// на 12 шаге logNumber() = undefined, number = 4 (глобальная переменная 10 меняется на локальную переменную 4)
// на 13 шаге console.log(number) = 4 (возвращается в консоль ссылка на расчитанное значение 4)
// на 14 шаге logNumber() = undefined, Вернуть значение: undefined, передается ссылка на значение локальных вычислений number = 4, удаляется лексическое окружение)
// на 15 шаге number = 4 (присваивается значение 4 и выводится данное итоговое значение)

//-----------------------------------------------------------------------------------------------------------------------

function createCounter() { // создаем функцию счетчика createCounter()
	let counter = 0; // создаем переменную счетчика counter со значением undefined и присваиваем ей 0 внутри createCounter(), при этом создается новое локальное лексическое окружение 
	const myFunction = function() { debugger; // создаем вложенное функциональное выражение в createCounter() со значением undefined и помещаем его в переменную myFunction
		counter = counter + 1; debugger; // создаем счетчик counter, прибавляющий + 1
		return counter; debugger; // возвращаем значение счетчика counter, в локальном лексическом окружении будет храниться ссылка на переменную counter
	};
	return myFunction; // возвращаем через return функции счетчика createCounter() вложенное функциональное выражение myFunction (одна функция возвращает другую) =>
} debugger; // при этом внутреннее лексическое окружение myFunction будет уничтожено по выполнению return myFunction!!! Но, наружу возвращаем описание действий вложенного функционального выражения myFunction - это ее ЗАМЫКАНИЕ!!!
const increment = createCounter(); debugger; // помещаем в переменную increment со значением undefined функциональное выражение createCounter() с ее вызывом и возвращением функционального выражения myFunction
const c1 = increment(); debugger; // возвращенное значение функции createCounter() в переменной increment присваиваем переменной c1, при вызове increment() и запуске createCounter() создается новое лексическое окружение
const c2 = increment(); debugger; // возвращенное значение функции createCounter() в переменной increment присваиваем переменной c2, при вызове increment() и запуске createCounter() создается новое лексическое окружение
const c3 = increment(); debugger; // возвращенное значение функции createCounter() в переменной increment присваиваем переменной c3, при вызове increment() и запуске createCounter() создается новое лексическое окружение
console.log(c1, c2, c3);

// функция createCounter() работает так:
// на 1 шаге number = 5 (присваивается значение 5)
// на 2 шаге number = 5 (ссылка на глобальное значение 5, переход к глобальной переменной number = 6)
// на 3 шаге number = 6 (5 меняется на 6, переход к вызову функции logNumber())
// на 4 шаге logNumber() = undefined, number = 6 (вызывается функция logNumber() со значением undefined, переход к локальной number = 4, создается лексическое окружение)
// на 5 шаге logNumber() = undefined, number = 4 (глобальная переменная 6 меняется на локальную переменную 4)
// на 6 шаге console.log(number) = 4 (возвращается в консоль ссылка на расчитанное значение 4)
// на 7 шаге logNumber() = undefined, Вернуть значение: undefined, передается ссылка на значение локальных вычислений number = 4, удаляется лексическое окружение)
// на 8 шаге number = 4 (присваивается значение 4, переход к глобальной переменной number = 10)
// на 9 шаге number = 10 (4 меняется на 10)
// на 10 шаге number = 10 (переход к вызову функции logNumber())
// на 11 шаге logNumber() = undefined, number = 10 (вызывается функция logNumber() со значением undefined, переход к локальной number = 4, создается лексическое окружение)
// на 12 шаге logNumber() = undefined, number = 4 (глобальная переменная 10 меняется на локальную переменную 4)
// на 13 шаге console.log(number) = 4 (возвращается в консоль ссылка на расчитанное значение 4)
// на 14 шаге logNumber() = undefined, Вернуть значение: undefined, передается ссылка на значение локальных вычислений number = 4, удаляется лексическое окружение)
// на 15 шаге number = 4 (присваивается значение 4 и выводится данное итоговое значение)