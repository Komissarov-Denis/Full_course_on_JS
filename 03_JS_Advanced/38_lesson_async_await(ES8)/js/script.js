// ПЕРВОЕ ПРИЛОЖЕНИЕ!!!

'use strict';

// PROMISE(ES6) - обещания помогают работать с асинхронными операциями в таймаутах или запросах на сервер
console.log('Запрос данных....');
setTimeout(() => {
	console.log('Подготовка данных...');
	const product = {
		name: 'TV',
		price: 2000,
	};
	setTimeout(() => {
		product.status = 'ordered';
		console.log(product);
	}, 4000);
}, 2000);
// Получил с интервалом 
// Запрос данных.... 
// 2 сек Подготовка данных...
// 4 сек { name: 'TV', price: 2000, status: 'ordered' }
// все это создает callback hell - ад обратных вызовов с кучей задержек, а коллбэков может быть множество в скрипте, чтобы избежать его применяют ПРОМИСЫ

console.log('Запрос данных....');
const req = new Promise(function(resolve, reject) { // в промис помещаем колбэк функцию с аргументами resolve = выполнено и reject = не выполнено, эти аргументы обозначают тоже функции, которые можно передавать 
	setTimeout(() => { // т.е. направляем запрос на сервер и ждем получение результата product, получаем его через 2 сек.
		console.log('Подготовка данных...');
		const product = {
			name: 'TV',
			price: 2000,
		};
		resolve(product); // если успешно отработал асинхронный код product, запускается данная функция... В нее мы передаем данные product
	}, 2000);
});
req.then((product) => { // для обработки положительного результата функции resolve() используем метод then(), от принимает внутрь себя тот аргумент с функции resolve()
	const req2 = new Promise(function(resolve, reject) {
		setTimeout(() => { // далее запустится асинхронная операция, она product замодифицирует и через 4 сек. выведет в консоль
			product.status = 'ordered';
			resolve(product);
		}, 4000);
	});
	req2.then((data) => {
		console.log(data);
	});
});
// Получил с интервалом 
// Запрос данных.... 
// 2 сек Подготовка данных...
// 4 сек { name: 'TV', price: 2000, status: 'ordered' }

console.log('Запрос данных....');
const req = new Promise(function(resolve, reject) { // в промис помещаем колбэк функцию с аргументами resolve = выполнено и reject = не выполнено, эти аргументы обозначают тоже функции, которые можно передавать 
	setTimeout(() => { // т.е. направляем запрос на сервер и ждем получение результата product, получаем его через 2 сек.
		console.log('Подготовка данных...');
		const product = {
			name: 'TV',
			price: 2000,
		};
		resolve(product); // если успешно отработал асинхронный код product, запускается данная функция... В нее мы передаем данные product
	}, 2000);
});
req.then((product) => { // для обработки положительного результата функции resolve() используем метод then(), от принимает внутрь себя тот аргумент с функции resolve()
	return new Promise(function(resolve, reject) { // заменим переменную командой return
		setTimeout(() => { // далее запустится асинхронная операция, она product замодифицирует и через 4 сек. выведет в консоль
			product.status = 'ordered';
			resolve(product);
		}, 4000);
	});
}).then((data) => { // тут так же произошла замена, теперь мы избавились от колбэков и выполняем операции по цепочке методов then()
	data.modify = true;
	data.upload = false;
	return data;
}).then((data) => {
	console.log(data);
});
// Получил с интервалом 
// Запрос данных.... 
// 2 сек Подготовка данных...
// 4 сек { name: 'TV', price: 2000, status: 'ordered', modify: true, upload: false }

console.log('Запрос данных....');
const req = new Promise(function(resolve, reject) { // в промис помещаем колбэк функцию с аргументами resolve = выполнено и reject = не выполнено, эти аргументы обозначают тоже функции, которые можно передавать 
	setTimeout(() => { // т.е. направляем запрос на сервер и ждем получение результата product, получаем его через 2 сек.
		console.log('Подготовка данных...');
		const product = {
			name: 'TV',
			price: 2000,
		};
		resolve(product); // если успешно отработал асинхронный код product, запускается данная функция... В нее мы передаем данные product
	}, 2000);
});
req.then((product) => { // для обработки положительного результата функции resolve() используем метод then(), от принимает внутрь себя тот аргумент с функции resolve()
	return new Promise(function(resolve, reject) { // заменим переменную командой return
		setTimeout(() => { // далее запустится асинхронная операция, она product замодифицирует и через 4 сек. выведет в консоль
			product.status = 'ordered';
			reject(); // будет выполняться при ошибке и не получении данных от сервера
		}, 4000);
	});
}).then((data) => { // тут так же произошла замена, теперь мы избавились от колбэков и выполняем операции по цепочке методов then()
	data.modify = true;
	data.upload = false;
	return data;
}).then((data) => {
	console.log(data);
}).catch(() => {
	console.error('Произошла ошибка...')
});
// Получил с интервалом 
// Запрос данных.... 
// 2 сек Подготовка данных...
// 4 сек Произошла ошибка...

console.log('Запрос данных....');
const req = new Promise(function(resolve, reject) { // в промис помещаем колбэк функцию с аргументами resolve = выполнено и reject = не выполнено, эти аргументы обозначают тоже функции, которые можно передавать 
	setTimeout(() => { // т.е. направляем запрос на сервер и ждем получение результата product, получаем его через 2 сек.
		console.log('Подготовка данных...');
		const product = {
			name: 'TV',
			price: 2000,
		};
		resolve(product); // если успешно отработал асинхронный код product, запускается данная функция... В нее мы передаем данные product
	}, 2000);
});
req.then((product) => { // для обработки положительного результата функции resolve() используем метод then(), от принимает внутрь себя тот аргумент с функции resolve()
	return new Promise(function(resolve, reject) { // заменим переменную командой return
		setTimeout(() => { // далее запустится асинхронная операция, она product замодифицирует и через 4 сек. выведет в консоль
			product.status = 'ordered';
			resolve(product);
		}, 4000);
	});
}).then((data) => { // тут так же произошла замена, теперь мы избавились от колбэков и выполняем операции по цепочке методов then()
	data.modify = true;
	data.upload = false;
	return data;
}).then((data) => {
	console.log(data);
}).catch(() => {
	console.error('Произошла ошибка...')
}).finally(() => { // сюда можно поместить часть кода для очистки формы на страничке!!! Она отработает не зависимо от успешности получения данных от сервера!!!
	console.log('Finally...')
});
// Получил с интервалом 
// Запрос данных.... 
// 2 сек Подготовка данных...
// 4 сек { name: 'TV', price: 2000, status: 'ordered', modify: true, upload: false }
//       Finally...

const test = time => { //создаем функцию test с аргументом time
	return new Promise(resolve => {
		setTimeout(() => {
			resolve();
		}, time);
	});
};
// test(1000).then(() => console.log('1000 ms')); // данную функцию удобно применять для запуска одинаковых операций через определенный промежуток времени
// test(3000).then(() => console.log('3000 ms')); 
// Получил через соответствующее время:
// 1000 ms
// 3000 ms
// данные промисы мы можем передать в массив Promise =>
Promise.all([test(1000), test(3000)]).then(() => {
	console.log('All');
}); // тут Promise выступает глобальным объектом с методом all(), в котором есть массив с промиссами и который можно обработать then(). Promise.all() служит для того, чтобы убедиться в выполнении всех Promise
Promise.race([test(1000), test(3000)]).then(() => {
	console.log('All');
}); // Promise.race() выполняется при отработке самого первого Promise
