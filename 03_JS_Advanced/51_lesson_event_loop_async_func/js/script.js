'use strict';

console.log(1); // сначала код запускает синхронную функцию
setTimeout(() => { // далее - ассинхронную функцию с задержкой в 2000 миллисек
	console.log('timeout_2000');}, 2000);
setTimeout(() => { // далее - ассинхронную функцию с задержкой в 4000 миллисек
	console.log('timeout_4000');
}, 4000);
console.log(2);  // далее - код запускает синхронную функцию
// получил:
// 1
// 2
// timeout_2000
// timeout_4000



// let k = 0; 
// function count() {
// 	for (let i = 0; i < 1e9; i++) {
// 		k++;
// 	}
// 	alert('Done!');
// }
// count(); // пообный код моет на долго повесить страницу, поэтому рекомендуется все расчеты разбивать на этапы, с последовательным движение от одного к другому!!!


setTimeout(() => { // программное поведение: setTimeout() изначально проходит через асинхронную часть, попадает в WEB Apis, записывается там, а уж потом идет в CallBack Queue 
	console.log(1); // соответственно, если первоначальная операция асинхронна, то первой выполнится синхронная операция, а потом асинхронная!!!
}, 0); // если в данном месте стоит нуль, или что-то от нуля до трех, то автоматом код подставляет 4 миллисекунды для синхронизации задержки с различными браузерами!!!
console.log(2);
// получил:
// 2
// 1