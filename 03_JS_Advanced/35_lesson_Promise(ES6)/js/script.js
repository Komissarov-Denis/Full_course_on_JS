// ПЕРВОЕ ПРИЛОЖЕНИЕ!!!

'use strict';

// PROMISE(ES6) - обещания помогают работать с асинхронными операциями в таймаутах или запросах на сервер
console.log('Запрос данных....');
setTimeout(() => { // прописываем асинхронный код
	console.log('Подготовка данных...');
	const product = { // создаем объект product{}
		name: 'TV',
		price: 2000,
	}; // => ПРЕДСТАВИМ, ЧТО ЭТО ДАННЫЕ ОТ СЕРВЕРА!!!
	setTimeout(() => { // прописываем асинхронный код
		product.status = 'ordered';
		console.log(product);
	}, 4000); // => ПРЕДСТАВИМ, ЧТО МЫ МОДИФИЦИРУЕМ ЭТИ ДАННЫЕ!!!
}, 2000);
// Получил с интервалом:
// Запрос данных.... 
// 2 сек Подготовка данных...
// 4 сек { name: 'TV', price: 2000, status: 'ordered' }
// все это создает callback hell - ад обратных вызовов с кучей задержек, а коллбэков может быть множество в скрипте, чтобы избежать его применяют ПРОМИСЫ

// resolve********************************************************
console.log('Запрос данных....');
const req = new Promise(function(resolve, reject) { // с помощью конструктора new Promise() создаем запрос и в него помещаем коллбэк функцию с аргументами resolve = выполнено и reject = не выполнено, эти аргументы обозначают тоже функции, которые можно передавать 
	setTimeout(() => { // т.е. направляем запрос на сервер и ждем получение результата product, получаем его через 2 сек.
		console.log('Подготовка данных...');
		const product = { // создаем объект product{}
			name: 'TV',
			price: 2000,
		};
		resolve(product); // если успешно отработал асинхронный код product, запускается функция resolve(product), в нее мы передаем данные объекта product{}
	}, 2000);
}); // => ПРЕДСТАВИМ, ЧТО ЭТО ДАННЫЕ ОТ СЕРВЕРА!!!
req.then((product) => { // метод then(product) будет выполняться на промисе в случае положительного результата обработки коллбэк функции и он принимает внутрь себя этот аргумент product{} 
	const req2 = new Promise(function(resolve, reject) { // обернем еще и объект req2{} тоже в промис
		setTimeout(() => { // далее запустится асинхронная операция, она product{} замодифицирует и через 4 сек. выведет в консоль
			product.status = 'ordered';
			resolve(product);
		}, 4000); // => ПРЕДСТАВИМ, ЧТО МЫ МОДИФИЦИРУЕМ ЭТИ ДАННЫЕ!!!
	});
	req2.then((data) => { // в data будет помещен модифицированный объект product{}
		console.log(data); // далее объект product{} будет выведен в консоль
	});
}); // ПРЕИУЩЕСТВО ПЕРЕД КОЛЛБЭКАМИ - МЫ МОЖЕМ ВОЗВРАЩАТЬ ПРОМИСЫ и then ПО ЦЕПОЧКЕ, ВЫПОЛНЕНИЕ КАЖДОЙ АСИНХРОВННОЙ ОПЕРАЦИИ ЗАПУСКАЕТ СЛЕДУЩУЮ!!!
// Получил с интервалом:
// Запрос данных.... 
// 2 сек Подготовка данных...
// 4 сек { name: 'TV', price: 2000, status: 'ordered' }


console.log('Запрос данных....');
const req = new Promise(function(resolve, reject) { // с помощью конструктора new Promise() создаем запрос и в него помещаем коллбэк функцию с аргументами resolve = выполнено и reject = не выполнено, эти аргументы обозначают тоже функции, которые можно передавать 
	setTimeout(() => { // т.е. направляем запрос на сервер и ждем получение результата product, получаем его через 2 сек.
		console.log('Подготовка данных...');
		const product = { // создаем объект product{}
			name: 'TV',
			price: 2000,
		};
		resolve(product); // если успешно отработал асинхронный код product, запускается функция resolve(product), в нее мы передаем данные объекта product{}
	}, 2000);
}); // => ПРЕДСТАВИМ, ЧТО ЭТО ДАННЫЕ ОТ СЕРВЕРА!!!
req.then((product) => { // метод then(product) будет выполняться на промисе в случае положительного результата обработки коллбэк функции и он принимает внутрь себя этот аргумент product
	return new Promise(function(resolve, reject) { // заменим переменную командой return и будем возвращать новый промис с асинхронной функцией, чтобы в данном промисе не использовать коллбэк функцию
		setTimeout(() => { // далее запустится асинхронная операция resolve(product), она product{} замодифицирует и через 4 сек. вернет результат
			product.status = 'ordered';
			resolve(product);
		}, 4000); // => ПРЕДСТАВИМ, ЧТО МЫ МОДИФИЦИРУЕМ ЭТИ ДАННЫЕ!!!
	}); // req2.then((data) => стал недоступен, так как появился return, после которого останавливается выполнение функции, асинхронная функция завершится resolve(product) и через return возвратится результат, теперь нет смысла в переменной req2
}).then((data) => { // код стал оптимальнее, тут образовалась цепочка методов .then(), с помощью которых можно обрабатывать данный промис - new Promise(), => 
	data.modify = true;
	data.upload = false;
	return data;
}).then((data) => { // каждые текущие данные .then(data) приходят из предыдущей функции resolve(product) и далее обрабатываются выбранными нами методами
	console.log(data);
});
// Получил с интервалом:
// Запрос данных.... 
// 2 сек Подготовка данных...
// 4 сек { name: 'TV', price: 2000, status: 'ordered', modify: true, upload: false }


// reject**********************************************************
console.log('Запрос данных....');
const req = new Promise(function(resolve, reject) { // с помощью конструктора new Promise() создаем запрос и в него помещаем коллбэк функцию с аргументами resolve = выполнено и reject = не выполнено, эти аргументы обозначают тоже функции, которые можно передавать 
	setTimeout(() => { // т.е. направляем запрос на сервер и ждем получение результата product, получаем его через 2 сек.
		console.log('Подготовка данных...');
		const product = { // создаем объект product{}
			name: 'TV',
			price: 2000,
		};
		resolve(product); // если успешно отработал асинхронный код product, запускается функция resolve(product), в нее мы передаем данные объекта product{}
	}, 2000);
}); // => ПРЕДСТАВИМ, ЧТО ЭТО ДАННЫЕ ОТ СЕРВЕРА!!!
req.then((product) => { // метод then(product) будет выполняться на промисе в случае положительного результата обработки коллбэк функции и он принимает внутрь себя этот аргумент product
	return new Promise(function(resolve, reject) { // заменим переменную командой return и будем возвращать новый промис с асинхронной функцией, чтобы в данном промисе не использовать коллбэк функцию
		setTimeout(() => { // далее запустится асинхронная операция resolve(product), она product{} замодифицирует и через 4 сек. вернет результат
			product.status = 'ordered';
			reject(); // будет выполняться при ошибке и не получении данных от сервера, product{} можно не передавать, все .then() пропускаются и перемещается код в .catch()
		}, 4000); // => ПРЕДСТАВИМ, ЧТО МЫ МОДИФИЦИРУЕМ ЭТИ ДАННЫЕ!!!
	}); // req2.then((data) => стал недоступен, так как появился return, после которого останавливается выполнение функции, асинхронная функция завершится resolve(product) и через return возвратится результат, теперь нет смысла в переменной req2
}).then((data) => { // код стал оптимальнее, тут образовалась цепочка методов .then(), с помощью которых можно обрабатывать данный промис - new Promise(), => 
	data.modify = true;
	data.upload = false;
	return data;
}).then((data) => { // каждые текущие данные .then(data) приходят из предыдущей функции resolve(product) и далее обрабатываются выбранными нами методами
	console.log(data);
}).catch(() => { // для обработки ошибки есть блок кода .catch()
	console.error('Произошла ошибка...') // выводим сообщение при ошибке в консоль
});
// Получил с интервалом:
// Запрос данных.... 
// 2 сек Подготовка данных...
// 4 сек Произошла ошибка...


//*************************************************************
console.log('Запрос данных....');
const req = new Promise(function(resolve, reject) { // с помощью конструктора new Promise() создаем запрос и в него помещаем коллбэк функцию с аргументами resolve = выполнено и reject = не выполнено, эти аргументы обозначают тоже функции, которые можно передавать 
	setTimeout(() => { // т.е. направляем запрос на сервер и ждем получение результата product, получаем его через 2 сек.
		console.log('Подготовка данных...');
		const product = { // создаем объект product{}
			name: 'TV',
			price: 2000,
		};
		resolve(product); // если успешно отработал асинхронный код product, запускается функция resolve(product), в нее мы передаем данные объекта product{}
	}, 2000);
}); // => ПРЕДСТАВИМ, ЧТО ЭТО ДАННЫЕ ОТ СЕРВЕРА!!!
req.then((product) => { // метод then(product) будет выполняться на промисе в случае положительного результата обработки коллбэк функции и он принимает внутрь себя этот аргумент product
	return new Promise(function(resolve, reject) { // заменим переменную командой return и будем возвращать новый промис с асинхронной функцией, чтобы в данном промисе не использовать коллбэк функцию
		setTimeout(() => { // далее запустится асинхронная операция resolve(product), она product{} замодифицирует и через 4 сек. вернет результат
			product.status = 'ordered';
			resolve(product);
		}, 4000);
	});
}).then((data) => { // код стал оптимальнее, тут образовалась цепочка методов .then(), с помощью которых можно обрабатывать данный промис - new Promise(), => 
	data.modify = true;
	data.upload = false;
	return data;
}).then((data) => { // каждые текущие данные .then(data) приходят из предыдущей функции resolve(product) и далее обрабатываются выбранными нами методами
	console.log(data);
}).catch(() => { // для обработки ошибки есть блок кода .catch()
	console.error('Произошла ошибка...') // выводим сообщение при ошибке в консоль
}).finally(() => { // как пример: сюда можно поместить часть кода для очистки формы на страничке!!! Она отработает не зависимо от успешности получения данных от сервера!!!
	console.log('Finally...')
});
// Получил с интервалом:
// Запрос данных.... 
// 2 сек Подготовка данных...
// 4 сек { name: 'TV', price: 2000, status: 'ordered', modify: true, upload: false }
// Finally...
//*************************************************************

// Promise.all и Promise.race**********************************
const test = time => { // создаем функцию test() с аргументом (time), тоже самое - const test = function(time) {}, она принимает количество времени
	return new Promise(resolve => { // будем возвращать данные промиса new Promise(), редко бывает, что аргумент reject не требуется
		setTimeout(() => { // выполняться будет resolve() в асинхронной функции через время time
			resolve();
		}, time);
	});
};
test(1000).then(() => console.log('1000 ms')); // данную функцию удобно применять для запуска одинаковых операций через определенный промежуток времени
test(3000).then(() => console.log('3000 ms')); 
// Получил через соответствующее время:
// 1000 ms
// 3000 ms
// данные промисы мы можем передать в массив Promise =>
Promise.all([test(1000), test(3000)]).then(() => { // Promise выступает как глобальный объект с методом all() и принимает внутрь себя массив [], который можно обработать .then()
	console.log('All'); // Promise.all() служит для того, чтобы убедиться в выполнении всех Promise
}); // как пример: направление нескольких запросов разным серверам для получения различных изображений, ответ поступает с задержкой, но изображения должны быть выведены одновременно по загрузке
Promise.race([test(1000), test(3000)]).then(() => { // Promise.race() выполняется при отработке самого первого Promise
	console.log('All');
});
// Получил с интервалом:
// 1000 ms
// All
// 3000 ms
// All