import { Component } from 'react';

import AppInfo from '../app-info/app-info';
import SearchPanel from '../search-panel/search-panel';
import AppFilter from '../app-filter/app-filter';
import EmployeesList from '../employees-list/employees-list';
import EmployeesAddForm from '../employees-add-form/employees-add-form';

import './app.css';

class App extends Component { // APP.js - данный компонент является источником истины, так как обязан контролировать все остальные компоненты и их данные 

	constructor(props) {
		super(props); 
		this.state = {
			data: [
				{
					name: 'John C.', 
					salary: 800,
					increase: false,
					rise: false,
					id: 1,
				},
				{
					name: 'Alex M.', 
					salary: 3000,
					increase: false,
					rise: false,
					id: 2,
				},
				{
					name: 'Carl W.', 
					salary: 5000,
					increase: false,
					rise: false,
					id: 3,
				}
			],
			term: '', // для обработки поля ввода как state (зависит от предыдущего состояния), необходимо создать дополнительные ключевое свойство, в которое будем помещать вводимые данные в строку поиска input, далее в render() фильтруем введенные данные
			filter: 'all', // для обработки фильтров как state (зависит от предыдущего состояния), в filter: '' прописываем filter: 'all', чтобы подсвечивалась первая кнопка и все были отфильтрованы первоначально
		}
        this.maxId = 4;
	}

	deleteItem = (id) => { // таким образом через изменение состояния setState по иерархии можно передавать функцию по удалению
		this.setState(({data}) => { // вытаскиваем значение data из массива с объектами по уникальному идентификатору

			//----первый способ---------------------
			// const index = data.findIndex(elem => elem.id === id); // находим индекс объекта c помощью метода findIndex(), который в себя принимает коллбэк функцию, которая при возврате true, передает в метод номер элемента, на котором сработал этот коллбэк
			// console.log(index) // затем берем ID и по нему находим нужный для удаления объект внутри массива, далее будем изменять State для формирования нового состояния
						
			// const before = data.slice(0, index); // slice() - метод, копирующий часть массива и создающий новый с 0 индекса до найденного индекса, не включительно найденного индекса
			// const after = data.slice(index + 1);  // slice() - метод, копирующий часть массива и создающий новый с найденного индекса до индекса + 1, не включительно найденного индекса
			// const newArr = [...before, ...after];
			// return{
			// 	data: newArr
			// }
			//--------------------------------------	
			
			//----второй способ---------------------
			return{
				data: data.filter(item => item.id !== id) // берем данные из data, запускаем метод filter()/создает новый массив со всеми элементами, прошедшими проверку, задаваемую в передаваемой функции/, 
			} // т.е. подходит для сохранения ИММУТАБЕЛЬНОСТИ ранее созданного объекта => data.filter() отфильтрует данные, в результате останутся только те элементы, ID которых не совпадают с ID удаляемого элемента  
			//--------------------------------------	
			
		}) // как итог: вернется новый массив
	}
	
    addItem = (name, salary) => { // создаем новый объект с передачей ему аргументов /name, salary/
        const newItem = {
            name, 
            salary,
            increase: false,
			rise: false,
            id: this.maxId++ // оператор инкремента, увеличения на 1 аргумента maxId компонента - постфиксный способ записи
        }
        this.setState(({data}) => { // передаем коллбэком данные через состояние нового объекта компонента 
            const newArr = [...data, newItem]; // создаем новый массив с передачей ему через спред оператор данных компонента, а также данные нового элемента при отправке формы нового сотрудника
            return {
                data: newArr
            }
        });
    }

	//--------------------------------------------------------------------------------------------------------------------------------------------
	//--------------------------------------------------------------------------------------------------------------------------------------------	
	// onToggleIncrease = (id) => { // данный метод будет изменять значение increase на противоположный у определенного элемента по id			
		//-первый самый сложный способ вытаскивать рандомный объект их рандомного места-----------------------------------------------------------
		// this.setState(({data}) => { // обращаемся к setState и вытаскиваем данные data
			// const index = data.findIndex(elem => elem.id === id); // получаем индекс нашего объекта в данных data через метод findIndex() с применением коллбэк функции по ID элемента
			// const oldItem = data[index]; // oldObj - это старый объект /промежуточная переменная/ и получаем данные по индексу
			// const newItem = {...oldItem, increase: !oldItem.increase}; // методом разворота spread() разворачиваем в новом объекте старый объект, что не нарушает принципов иммутабельности и мы можем добавлять новые свойства в него, при этом все что будет после запятой /{...oldItem, increase: !oldItem.increase}/ - будет заменять предыдущие данные на противоположные increase: false => на true!!!
			// const newArr = [...data.slice(0, index), newItem, ...data.slice(index + 1)]; // для переработки всего data, создаем новый массив данных с помощью метода разворота spread() от части before/...data.slice(0, index)/ до части after /...data.slice(index + 1)/ совместно с newItem
			// return {
			// 	data: newArr // возвращаем объект, содержащий новые свойства data, в котором помещен новый массив newArr
			// }
		// })
		//----------------------------------------------------------------------------------------------------------------------------------------

		//-второй менее понятный способ вытаскивать рандомный объект их рандомного места----------------------------------------------------------
		// this.setState(({data}) => ({ // возвращаем сразу объект данных со свойством data с помощью метода перебора массива map(), так как менять напрямую менять объект не можем
		// 	data: data.map(item => {  // item - это каждый объект внутри нашего нового массива data, соответственно: к перебору всех объектов массива /data/ коллбэк функцией, мы можем применить условие: 
		// 		if (item.id === id) { // если каждый ID объекта массива совпадает с тем ID, который к нам пришел внутри метода /ID найденного объекта, который мы хотим изменить прямо сейчас/
		// 			return {...item, increase: !item.increase} // то возвращаем новый объект из коллбэк функции, при этом все что будет после запятой /{...item, increase: !item.increase}/ - будет заменять предыдущие данные на противоположные increase: false => на true!!!
		// 		}
		// 		return item; // далее возвращаем объект, если условие не совпало
		// 	})
		// })) // как итог получаем массив объектов с одним новым измененным значением
		//----------------------------------------------------------------------------------------------------------------------------------------
	// }

	// onToggleRise = (id) => { // данный метод будет изменять значение Rise на противоположный у определенного элемента по id
	// 	this.setState(({data}) => ({ // возвращаем сразу объект данных со свойством data с помощью метода перебора массива map(), так как менять напрямую менять объект не можем
	// 		data: data.map(item => {  // item - это каждый объект внутри нашего нового массива data, соответственно: к перебору всех объектов массива /data/ коллбэк функцией, мы можем применить условие: 
	// 			if (item.id === id) { // если каждый ID объекта массива совпадает с тем ID, который к нам пришел внутри метода /ID найденного объекта, который мы хотим изменить прямо сейчас/
	// 				return {...item, rise: !item.rise} // то возвращаем новый объект из коллбэк функции, при этом все что будет после запятой /{...item, rise: !item.rise}/ - будет заменять предыдущие данные на противоположные increase: false => на true!!!
	// 			}
	// 			return item; // далее возвращаем объект, если условие не совпало
	// 		})
	// 	})) // как итог получаем массив объектов с одним новым измененным значением
	// }
	//--------------------------------------------------------------------------------------------------------------------------------------------	
	//-заменим-на-оптимизированный-вариант-но-более-сложный =>=>=>=>=>=>
	//--------------------------------------------------------------------------------------------------------------------------------------------

	//=>=>=>=>=>=>
	onToggleProp = (id, prop) => { // данный метод будет изменять значение не конкретного свойства на противоположный у определенного элемента по id, а просто prop рандомное как второй аргумент
		this.setState(({data}) => ({ // возвращаем сразу объект данных со свойством data с помощью метода перебора массива map(), так как менять напрямую менять объект не можем
			data: data.map(item => {  // item - это каждый объект внутри нашего нового массива data, соответственно: к перебору всех объектов массива /data/ коллбэк функцией, мы можем применить условие: 
				if (item.id === id) { // если каждый ID объекта массива совпадает с тем ID, который к нам пришел внутри метода /ID найденного объекта, который мы хотим изменить прямо сейчас/
					return {...item, [prop]: !item[prop]} // то возвращаем новый объект из коллбэк функции, при этом все что будет после запятой /{...item, [prop]: !item[prop]}/ - будет заменять предыдущие данные на противоположные increase: false => на true!!!
				}
				return item; // далее возвращаем объект, если условие не совпало
			})
		})) // как итог получаем массив объектов с одним новым измененным значением
	}

	searchEmp = (items, term) => { // метод поиска для строки поиска /term - условия/ /items - возвращаемый массив данных/, т.е. данные, которые вводит пользователь в строку поиска input
		if (term.length === 0) { // проверяем на заполнение строки, если строка пустая, возвращаем items - массив, который к нам придет
			return items;
		}
		return items.filter(item => { // если условие не отработало, можем отфильтровать получаемый массив items методом filter() по каждому элементу item через коллбэк функцию
			return item.name.indexOf(term) > -1 // indexOf() - метод для полной строки в name, перебирающий подстроки приходящие в terms (кусочки строк), если этот метод ничего не находит, то возвращает минус один и условие не выполняется
		}) // если indexOf() нашел нужный кусочек строки, то возвращается индекс строки, в которой найден кусочек подстроки, соответственно вернется массив элементов, подходящих под наш поиск 
	}

	onUpdateSearch = (term) => { // для обеспечения подъема события из компонента SearchPanel /строки поиска input/, создаем метод onUpdateSearch(), который принимает значение строки term
		this.setState({term}) // не зависим от предыдущего состояния объекта, поэтому можно записать this.setState({term: term}) или сокращенно this.setState({term})
	}

	filterPost = (items, filter) => { // метод filterPost будут обрабатывать данные компонента AppFilter, для этого принимает два аргумента items и filter
		switch (filter) {
			case 'rise': // идут на повышение
				return items.filter(item => item.rise) // возвращаем из фильтра массив работников, идущих на повышение /(item => item.rise) - берем каждый элемент в массиве, возвращаем те элементы, которые в rise в логическом контексте true/
			case 'moreThen1000':
				return items.filter(item => item.salary > 1000) // возвращаем из фильтра массив работников, у которых зарплата выше 1000$
			default:
				return items // если нет фильтров, возвращаем массив как есть
		}
	}

	onFilterSelect = (filter) => { // метод, активирующий класс активности
		this.setState({filter}); // изменяем в состоянии объект с фильтром и передаем вниз по иерархии
	}

	render() {

		const {data, term, filter} = this.state; // для обработки поля ввода, вытаскиваем при помощи принципа деструктуризации data и term из объекта компонента this.state
		const employees = this.state.data.length; // length - даст общее количество сотрудников объекта state подсчитав все данные массива data
		const increased = this.state.data.filter(item => item.increase).length; // фильтруем массив методом filter(), который вернет новый массив, который после фильтрации коллбэком вернет сотрудников, которые получат премию /перебираем item и возвращаем только те, у которых increase = true/, length - даст количество
		// const visibleData = this.searchEmp(data, term); // данные, которые будут отображаться в виде массива данных items, которые либо выводятся как есть при пустой строке input, либо измененные новые данные
		//=>=>=>=>=>=> с применением фильтра, заменяем const visibleData = this.searchEmp(data, term)
		const visibleData = this.filterPost(this.searchEmp(data, term), filter); // комбинируем фильтрацию с поиском, а затем фильтруем отфильтрованный массив по ЗП и повышению, а также передаем сюда вторым аргументом state > filter

		return (
			<div className="app">
				<AppInfo
					employees={employees}
					increased={increased}
				/>

				<div className="search-panel">
					<SearchPanel
						onUpdateSearch = {this.onUpdateSearch} // передаем созданный метод onUpdateSearch() в компонент SearchPanel, что формирует поднятие события и дает возможность использовать этот метод в SearchPanel
					/>
					<AppFilter filter={filter} onFilterSelect={this.onFilterSelect} // передаем текущий state как prop в AppFilter
					/> 
				</div> 

				<EmployeesList 
					// data = {this.state.data} // для обработки поля ввода, заменяем
					//=>=>=>=>=>=>
					data = {visibleData} // заменил и передал visibleData
					onDelete = {this.deleteItem} // проверяем действие по удалению конкретного ID при нажатии на корзинку
					// onToggleIncrease = {this.onToggleIncrease} // передаем глубже данные методы через контекст вызова в текущий компонент EmployeesList (погружение дынных или событий)
					// onToggleRise = {this.onToggleRise} // передаем глубже данные методы через контекст вызова в текущий компонент EmployeesList (погружение дынных или событий)
					//=>=>=>=>=>=>
					onToggleProp = {this.onToggleProp} // заменил методы onToggleIncrease и onToggleRise на оптимизированный метод
				/>

				<EmployeesAddForm
					onAdd = {this.addItem} // проверяем действие по добавлению конкретного элемента при нажатии на кнопку добавить
				/>
			</div>
		);

	}

}
export default App;